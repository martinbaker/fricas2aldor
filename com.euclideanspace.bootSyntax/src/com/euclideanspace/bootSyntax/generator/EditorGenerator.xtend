/*
 * generated by Xtext 2.12.0
 */
package com.euclideanspace.bootSyntax.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.euclideanspace.bootSyntax.editor.Model
import com.euclideanspace.bootSyntax.editor.Declaration
import com.euclideanspace.bootSyntax.editor.Package
import com.euclideanspace.bootSyntax.editor.Comment
import com.euclideanspace.bootSyntax.editor.Documentation
import com.euclideanspace.bootSyntax.editor.Defparameter
import com.euclideanspace.bootSyntax.editor.Defconstant
import com.euclideanspace.bootSyntax.editor.Defconst
import com.euclideanspace.bootSyntax.editor.Defvar
import com.euclideanspace.bootSyntax.editor.FunctionDef
import com.euclideanspace.bootSyntax.editor.GlobalVariable
import com.euclideanspace.bootSyntax.editor.Statement
import com.euclideanspace.bootSyntax.editor.Loop
import com.euclideanspace.bootSyntax.editor.LoopCondition
//import com.euclideanspace.bootSyntax.editor.While
import com.euclideanspace.bootSyntax.editor.Do
//import com.euclideanspace.bootSyntax.editor.Until
//import com.euclideanspace.bootSyntax.editor.For
import com.euclideanspace.bootSyntax.editor.Where
import com.euclideanspace.bootSyntax.editor.Expr
import com.euclideanspace.bootSyntax.editor.Expression
import com.euclideanspace.bootSyntax.editor.ExitExpression
import com.euclideanspace.bootSyntax.editor.OrExpression
import com.euclideanspace.bootSyntax.editor.AndExpression
import com.euclideanspace.bootSyntax.editor.EqualityExpression
import com.euclideanspace.bootSyntax.editor.RelationalExpression
import com.euclideanspace.bootSyntax.editor.IsExpression
import com.euclideanspace.bootSyntax.editor.InExpression
import com.euclideanspace.bootSyntax.editor.SegmentExpression
import com.euclideanspace.bootSyntax.editor.AdditiveExpression
import com.euclideanspace.bootSyntax.editor.ExquoExpression
import com.euclideanspace.bootSyntax.editor.DivisionExpression
import com.euclideanspace.bootSyntax.editor.QuoExpression
import com.euclideanspace.bootSyntax.editor.ModExpression
import com.euclideanspace.bootSyntax.editor.RemExpression
import com.euclideanspace.bootSyntax.editor.MultiplicativeExpression
import com.euclideanspace.bootSyntax.editor.ExponentExpression
import com.euclideanspace.bootSyntax.editor.MapExpression
import com.euclideanspace.bootSyntax.editor.AssignExpression
import com.euclideanspace.bootSyntax.editor.EltExpression
import com.euclideanspace.bootSyntax.editor.UnaryExpression
import com.euclideanspace.bootSyntax.editor.VarOrFunction
import com.euclideanspace.bootSyntax.editor.Tuple
import com.euclideanspace.bootSyntax.editor.Literal
import com.euclideanspace.bootSyntax.editor.LispLiteral
import com.euclideanspace.bootSyntax.editor.SubLispLiteral
import com.euclideanspace.bootSyntax.editor.AnnotatedSubLispLiteral
import com.euclideanspace.bootSyntax.editor.ListLiteral
import com.euclideanspace.bootSyntax.editor.ListElement
import com.euclideanspace.bootSyntax.editor.ListComprehension
import com.euclideanspace.bootSyntax.editor.WhereExpression
import com.euclideanspace.bootSyntax.editor.IfExpression
import com.euclideanspace.bootSyntax.editor.LambdaExpression
import com.euclideanspace.bootSyntax.editor.Block
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.EList

/* rules for indentation
 * ---------------------
 * newline(indent) inserted after every declaration
 * newline(indent) inserted after every statement in block
 * 
 * should these be before?
 */

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EditorGenerator extends AbstractGenerator {

    var static GlobalScope vars = null;
    var String currentFile ="";
    var String currentFunction ="";
    var String bootPkg ="";
    /** statements that can't be output immediately, for example waiting
     * until after 'repeat'. Used in second (compileImplementation) pass*/
    var ArrayList<String> pendingStatements = new ArrayList<String>();
    var ArrayList<NamespaceScope> pendingWheres = new ArrayList<NamespaceScope>();
    var ArrayList<LambdaExpression> pendingLambda = new ArrayList<LambdaExpression>();
    /** 'locals' is used in second (compileImplementation) pass to
     * determine if we need to add :SExpression type. This is only
     * needed for first occurrence in function.
     * see getVariable */
    var ArrayList<String> locals = new ArrayList<String>();
    
 /*   override void beforeGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
      //System.out.println("before "+resource.className);
    }*/

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
      //System.out.println("do "+resource.className);
      //val TreeIterator<EObject> all = resource.allContents;
      //while (all.hasNext()) {
      //    System.out.println("doall "+all.next());
      //}
      if (vars === null) {
      	vars = new GlobalScope(null,null,null)
        val ResourceSet rs = resource.resourceSet;
        val EList<Resource> res = rs.getResources();
        for (Resource r:res) {
          var NamespaceScope x = null;
          className(r);
          var EObject m = r.contents.head;
          if (m instanceof Model)
            x = setNamespace(vars,0,m,WhereState.NotWhere,RefType.FileGlobal);
        }
      }
      className(resource);
      //System.out.println("currentFile="+currentFile+" import="+vars.importList(currentFile));
      fsa.generateFile(resource.className+".spad", compile(0,0,false,resource.contents.head as Model,WhereState.NotWhere,vars))
      fsa.generateFile("namespace.txt",vars.showDefs())
      fsa.generateFile("scopes.txt",vars.showScopes(0))
   }

    /** set currentFile which is package name*/
 	def className(Resource res) {
		var name = res.URI.lastSegment
		currentFile = name.substring(0, name.indexOf('.'))
		return currentFile;
	}

	def CharSequence newline(int indent) {
		var String s= System.lineSeparator()
		for(var int i=0; i<indent; i++) {
			s=s+"  "
		}
		return s
	}

    /*
     * cop (conditional open parenthesis)
     * This inserts open parenthesis only if it is required by
     * precedence rules.
     */
	def String cop(int innerprecedence,int outerprecedence) {
		if (innerprecedence < outerprecedence) return "(" else return ""
	}

    /*
     * ccp (conditional close parenthesis)
     * This inserts close parenthesis only if it is required by
     * precedence rules.
     */
	def String ccp(int innerprecedence,int outerprecedence) {
		if (innerprecedence < outerprecedence) return ")" else return ""
	}

    /**
     * converts long filename to format used by old Microsoft OS
     */
	def String shortName(String a) {
		var int last=4;
		var String b = a.replaceAll("-","");
		b = b.replaceAll("_","");
		if (b.length()<4) last= b.length();
		"BOOL"+b.substring(0,last).toUpperCase();
	}

    /**
     * called when a variable name is used
     */
	def String getVariable(String a,boolean lhs) {
		var boolean addType = false;
		if (lhs) {
		  if (vars.isLocal(a,currentFunction)) {
		    if (!locals.contains(a)) {
		    	addType = true;
		    	locals.add(a);
		    }
		  }
		}
		if (addType) return a + ":SExpression";
		return a;
	}

/*
 * some keywords are changed so that they are not taken as keywords
 * in our language. This changes them back to what they should be.
 */
	def String cleanID(String a) {
		if (a.equals("if1")) return "if"
		if (a.equals("and1")) return "and"
		if (a.equals("or1")) return "or"
		if (a.equals("not1")) return "not"
		if (a.equals("is1")) return "is"
		if (a.equals("package1")) return "package"
		if (a.equals("local1")) return "local"
		if (a.equals("until1")) return "until"
		return a
	}

    /**
     * Model
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Model model,WhereState insideWhere,NamespaceScope parentScope)
	    '''
	    «val NamespaceScope scope =parentScope.getScope(model)»«
	    if (!(parentScope instanceof GlobalScope)) System.err.println("compile model expects parentScope to be GlobalScope")»«
	    if (!(scope instanceof FileScope)) System.err.println("compile model expects scope to be FileScope")»«
	    var String longName = "** no resource **"»«
	    IF model.eResource !== null»«{longName = model.eResource.className;null}»«
	    ENDIF»)abbrev package «shortName(longName)» «longName»
	    «longName»() : Exports == Implementation where«
	    compileExports(indent+1,precedence,model,WhereState.NotWhere,scope)»«
	    compileImplementation(indent+1,precedence,model,insideWhere,scope)»'''

    /**
     * Model
     */
	def NamespaceScope setNamespace(GlobalScope parent,int precedence,Model model,WhereState insideWhere,RefType refType) {
		val FileScope ns = new FileScope(parent,model,currentFile);
		parent.addSubscope(ns);
		for (Declaration x: model.declarations) {
		  setNamespace(ns,precedence,x,insideWhere,RefType.FileGlobal);
		}
		return ns;
	}

    /**
     * Model
     */
	def CharSequence compileExports(int indent,int precedence,Model model,WhereState insideWhere,NamespaceScope scope)
	    '''
	    «newline(indent)»Exports ==> with«
	    FOR x:model.declarations»«compileExports(indent+1,precedence,x,insideWhere,scope)»«ENDFOR»'''

    /**
     * Model
     */
	def CharSequence compileImplementation(int indent,int precedence,Model model,WhereState insideWhere,NamespaceScope scope)
	    '''
	    «var ArrayList<String> imp = new ArrayList<String>()»«
	    newline(indent)»«
	    newline(indent)»Implementation ==> add«
	    newline(indent+1)»«
	    »import from BootEnvir«
	    {imp=vars.importList(currentFile);null}»«
	    FOR x:imp»«
	      newline(indent+1)»«
	      »import from «x»«
	    ENDFOR»«
	    newline(indent+1)»«
	    FOR x:model.declarations»«compile(indent+1,precedence,false,x,insideWhere,scope)»«ENDFOR»'''

    /**
     * Declaration
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Declaration declaration,WhereState insideWhere,RefType refType) {
	    if (declaration instanceof Package)
	       return setNamespace(parent,precedence,declaration as Package,insideWhere,RefType.FileGlobal)
		if (declaration instanceof Defparameter)
	       return setNamespace(parent,precedence,declaration as Defparameter,insideWhere,RefType.FileGlobal)
	    if (declaration instanceof Defconstant)
	       return setNamespace(parent,precedence,declaration as Defconstant,insideWhere,RefType.FileGlobal)
	    if (declaration instanceof Defconst)
	       return setNamespace(parent,precedence,declaration as Defconst,insideWhere,RefType.FileGlobal)
	    if (declaration instanceof Defvar)
	       return setNamespace(parent,precedence,declaration as Defvar,insideWhere,RefType.FileGlobal)
	    if (declaration instanceof FunctionDef)
	       return setNamespace(parent,precedence,declaration as FunctionDef,insideWhere,RefType.InsideFunction)
	    if (declaration instanceof GlobalVariable)
	       return setNamespace(parent,precedence,declaration as GlobalVariable,insideWhere,RefType.FileGlobal)
	    return parent;
	}

    /**
     * Declaration
     */
	def CharSequence compileExports(int indent,int precedence,Declaration declaration,WhereState insideWhere,NamespaceScope parentScope)
	    '''
	    «IF declaration instanceof FunctionDef»«
	       compileExports(indent,precedence,declaration as FunctionDef,insideWhere,parentScope)»«ENDIF»'''

    /**
     * Declaration
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Declaration declaration,WhereState insideWhere,NamespaceScope parentScope)
	    '''
	    «newline(indent)»«
	    IF declaration instanceof Package»«
	       compile(indent,precedence,lhs,declaration as Package,insideWhere,parentScope)»«ENDIF»«
	    IF declaration instanceof Comment»«
	       compile(indent,precedence,lhs,declaration as Comment,insideWhere,parentScope)»«ENDIF»«
	    IF declaration instanceof Documentation»«
	       compile(indent,precedence,lhs,declaration as Documentation,insideWhere,parentScope)»«ENDIF»«
	    IF declaration instanceof FunctionDef»«
	       compile(indent,precedence,lhs,declaration as FunctionDef,insideWhere,parentScope)»«ENDIF»«
	    IF declaration instanceof Where»«
	       compile(indent,precedence,lhs,declaration as Where,insideWhere,parentScope)»«ENDIF»«
	    IF declaration instanceof GlobalVariable»«
	       compile(indent,precedence,lhs,declaration as GlobalVariable,insideWhere,parentScope)»«ENDIF»'''
	
	
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Package package1,WhereState insideWhere,RefType refType) {
		if (package1.p !== null) bootPkg = package1.p;
		val NamespaceScope ns = new NamespaceScope(parent,package1,bootPkg);
		parent.addSubscope(ns);
		return ns;
    }

    /**
     * Package
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Package package1,WhereState insideWhere,NamespaceScope parentScope)
	    '''«null»'''

    /**
     * Comment
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Comment comment,WhereState insideWhere,NamespaceScope parentScope)
	    '''
	    «IF comment.c !== null»«comment.c»«ENDIF»'''

   /**
     * Documentation
     *
     *	KW_CPAREN ('if' e=Expression | ei?='endif')
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Documentation documentation,WhereState insideWhere,NamespaceScope parentScope)
	    '''
	    «IF documentation.ei»)endif«
	    ELSEIF documentation.e !== null»)if «compile(indent,precedence,lhs,documentation.e,insideWhere,new NullScope(null,null,null))»«ENDIF»'''

    /**
     * Defparameter
     * 'DEFPARAMETER' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Defparameter defparameter,WhereState insideWhere,RefType refType) {
		val String nam = defparameter.name
		val NamespaceScope ns = new NamespaceScope(parent,defparameter,nam);
		parent.addSubscope(ns);
	    vars.addDefparam(nam);
	    return ns;
    }

    /**
     * Defconstant
     * 'DEFCONSTANT' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Defconstant defconstant,WhereState insideWhere,RefType refType) {
		val String nam = defconstant.name
		val NamespaceScope ns = new NamespaceScope(null,defconstant,nam);
		parent.addSubscope(ns);
	    vars.addDefconstant(nam);
	    return ns;
	}

    /**
     * Defconst
     * 'DEFCONST' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Defconst defconst,WhereState insideWhere,RefType refType) {
		val String nam = defconst.name
		val NamespaceScope ns = new NamespaceScope(null,defconst,nam);
		parent.addSubscope(ns);
	    vars.addDefconst(nam);
	    return ns;
	}

    /**
     * Defvar
     * 'DEFVAR' KW_OPAREN name=TK_ID (KW_COMMA e=Expression)? KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Defvar defvar,WhereState insideWhere,RefType refType) {
		val String nam = defvar.name
		val NamespaceScope ns = new NamespaceScope(null,defvar,nam);
		parent.addSubscope(ns);
	    vars.addDefvar(nam);
	    return ns;
	}

    /**
     * FunctionDef
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,FunctionDef function,WhereState insideWhere,RefType refType){
	    if (function.name !== null) {
	      currentFunction = function.name;
        }
		val FunctionDefScope ns = new FunctionDefScope(parent,function,currentFunction);
		parent.addSubscope(ns);
        var ArrayList<String> params = new ArrayList<String>();
        for (Expr p:function.params) {
          setNamespace(ns,precedence,p,insideWhere,RefType.Parameter)
          if (p instanceof VarOrFunction) {
          	val VarOrFunction v = p as VarOrFunction;
          	params.add(v.name);
          }
        }
        vars.addFunctionDef(function.name,null,currentFile,bootPkg,params,0);
	    if (function.st !== null)
	      setNamespace(ns,precedence,function.st,insideWhere,RefType.InsideFunction)
	    /*if (function.w !== null)
	      setNamespace(ns,precedence,function.w,insideWhere,RefType.InsideFunction)
	    for (NamespaceScope pw:pendingWheres) {
		  val UseMarkerScope u = new UseMarkerScope(parent,function,currentFunction,pw);
		  parent.addSubscope(u);
	    }
	    pendingWheres.clear();
	    */
	    return ns;
	}

    /**
     * FunctionDef
     * top level function definition, inner functions use lambda */
	def CharSequence compileExports(int indent,int precedence,FunctionDef function,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(function)»«
	    if (!(parentScope instanceof FileScope)) System.err.println("compile FunctionDef expects parentScope to be FileScope")»«
	    if (!(scope instanceof FunctionDefScope)) System.err.println("compile FunctionDef expects scope to be FunctionDefScope")»«
        newline(indent)»«
	    IF function.name !== null»«
	     {currentFunction = function.name;null}»«
	    ENDIF»«
	    IF function.name !== null»«vars.lookupSafeFunctionName(function.name)»«ENDIF»«
	    FOR x:function.fp»'«ENDFOR»: (BootEnvir«
	    IF function.j !== null»«function.j»«ELSE»«
	      FOR x:function.params», SExpression«ENDFOR»«
	    ENDIF») -> SExpression«
	    IF function.st !== null»«
	      compileExports(indent,precedence,function.st,insideWhere,scope)»«
	    ENDIF»«
	    IF function.w !== null»«
	      newline(indent)»«
	      compileExports(indent,precedence,function.w,insideWhere,scope)»«
	    ENDIF»«
	    FOR NamespaceScope pw:pendingWheres»«
	      //compileExports(indent,precedence,pw.getEobj(),WhereState.WritingWhere,scope)»«
	    ENDFOR»«
	    {pendingWheres.clear();null}»'''

    /**
     * FunctionDef:
    name=TK_ID fp+=KW_PRIME*
    (
      (KW_OPAREN (params+=Expression (KW_COMMA params+=Expression)*)? KW_CPAREN)
      |  j=TK_ID // support juxtapose
    )
	((KW_EQ2|m?=KW_MARROW) st=Statement)? // FunctionDef may be abstract
	
	(NL w=Where)?
	* 
	*/
	def CharSequence compile(int indent,int precedence,boolean lhs,FunctionDef function,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(function)»«
	    if (!(parentScope instanceof FileScope)) System.err.println("compile FunctionDef expects parentScope to be FileScope")»«
	    if (!(scope instanceof FunctionDefScope)) System.err.println("compile FunctionDef expects scope to be FunctionDefScope")»«
        {locals.clear();null}»«
	    IF function.name !== null»«
	     { currentFunction = function.name;null}»«
	    ENDIF»«
	    IF function.name !== null»«vars.lookupSafeFunctionName(function.name)»«ENDIF»«
	    FOR x:function.fp»'«ENDFOR»(bootEnvir«
	    IF function.j !== null»«function.j»«ELSE»«
	      FOR x:function.params»«
	        »,«compile(indent,precedence,true,x,insideWhere,scope)»«
	      ENDFOR»«
	    ENDIF»)«
	    IF function.st !== null»«
	      IF function.m» ==>«ELSE» ==«ENDIF»«
	      FOR String globVar: vars.getReadGlobal(currentFunction)»«
	        newline(indent+1)»«globVar»=getVar(bootEnvir,"«globVar»")«
	      ENDFOR»«
	      compile(indent,precedence,lhs,function.st,insideWhere,scope)»«
	    ENDIF»«
	    IF function.w !== null»«
	      newline(indent)»«
	      compile(indent,precedence,lhs,function.w,insideWhere,scope)»«
	    ENDIF»«
	    newline(indent)»«
	    FOR LambdaExpression le:pendingLambda»«
	      compile(indent,precedence,lhs,le,WhereState.WritingWhere,scope)»«
	    ENDFOR»«
	    {pendingLambda.clear();null}»'''

   /**
    * GlobalVariable
    */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,GlobalVariable globalVariable,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(null,globalVariable,null);
		parent.addSubscope(ns);
      if (globalVariable.name !== null) vars.addGlobal(globalVariable.name);
      return ns;
    }

   /**
    * GlobalVariable
    *
    * name=TK_ID KW_ASSIGN e=Expression */
	def CharSequence compile(int indent,int precedence,boolean lhs,GlobalVariable globalVariable,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(globalVariable)»«
        IF globalVariable.name !== null»«globalVariable.name»«ENDIF» :=«
	    IF globalVariable.e !== null»«compile(indent,precedence,lhs,globalVariable.e,insideWhere,scope)»«ENDIF»'''

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Statement statement,WhereState insideWhere,RefType refType) {
	  if (statement instanceof Loop)
	       return setNamespace(parent,precedence,statement as Loop,insideWhere,RefType.InsideFunction);
	  if (statement instanceof Do)
	       return setNamespace(parent,precedence,statement as Do,insideWhere,RefType.InsideFunction);
      if (statement instanceof Where)
	       return setNamespace(parent,precedence,statement as Where,insideWhere,RefType.InsideFunction);
	  if (statement instanceof Expr)
	       return setNamespace(parent,precedence,statement as Expr,insideWhere,RefType.InsideFunction);
	  return new NullScope(null,null,null);
    }

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def CharSequence compileExports(int indent,int precedence,Statement statement,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «IF statement instanceof Where»«
	       compileExports(indent,precedence,statement as Where,insideWhere,parentScope)»«
	    ENDIF»«
	    IF statement instanceof Expr»«
	       compileExports(indent,precedence,statement as Expr,insideWhere,parentScope)»«
	    ENDIF»'''

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 * 
 * Inside Block newlines are before statements
 */
  def CharSequence compile(int indent,int precedence,boolean lhs,Statement statement,WhereState insideWhere,NamespaceScope parentScope)
    '''
    «IF statement instanceof Comment»«
      compile(indent,precedence,lhs,statement as Comment,insideWhere,parentScope)»«ENDIF»«
    IF statement instanceof Loop»«
      compile(indent,precedence,lhs,statement as Loop,insideWhere,parentScope)»«ENDIF»«
    IF statement instanceof Do»«
      compile(indent,precedence,lhs,statement as Do,insideWhere,parentScope)»«ENDIF»«
    IF statement instanceof Where»«
      compile(indent,precedence,lhs,statement as Where,insideWhere,parentScope)»«ENDIF»«
    IF statement instanceof Expr»«
      compile(indent,precedence,lhs,statement as Expr,insideWhere,parentScope)»«ENDIF»«
    FOR s:pendingStatements»«
      newline(indent+1)»«
      s»«
    ENDFOR»«
      {pendingStatements.clear();null}»'''

/*
 * Loop:
 * c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block
 * 
 * Put space after each condition.
 * This code uses LoopCondition, While, For and Until directly rather
 * than calling their 'compile' functions. This is because trailing spaces
 * after newline are changed by auto-indent code.
 *
 */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Loop loop,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,loop,null);
	    parent.addSubscope(ns);
        for(LoopCondition x:loop.c) {
          if (x.f !== null)
            if (x.f.e !== null) setNamespace(ns,0,x.f.e,insideWhere,RefType.InsideFunction);
          if (x.w !== null)
            if (x.w.e !== null) setNamespace(ns,0,x.w.e,insideWhere,RefType.InsideFunction);
          if (x.u !== null)
            if (x.u.e !== null) setNamespace(ns,0,x.u.e,insideWhere,RefType.InsideFunction);
        }
        if (loop.e !== null) setNamespace(ns,0,loop.e,insideWhere,RefType.InsideFunction);
        if (loop.b !== null)
          setNamespace(ns,precedence,loop.b,insideWhere,RefType.InsideFunction);
        return ns;
      }
/*
 * Loop:
 * c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block
 * 
 * Put space after each condition.
 * This code uses LoopCondition, While, For and Until directly rather
 * than calling their 'compile' functions. This is because trailing spaces
 * after newline are changed by auto-indent code.
 *
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,Loop loop,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(loop)»«
        FOR x:loop.c»«
          IF x.f !== null»«
            »for «IF x.f.e !== null»«compile(indent,0,lhs,x.f.e,insideWhere,scope)» «ENDIF»«
          ENDIF»«
          IF x.w !== null»«
            »while «IF x.w.e !== null»«compile(indent,0,lhs,x.w.e,insideWhere,scope)»«
              IF x.w.n»«newline(indent)» «ELSE» «ENDIF»«
            ENDIF»«
          ENDIF»«
          IF x.u !== null»«
            »until «IF x.u.e !== null»«compile(indent,0,lhs,x.u.e,insideWhere,scope)»«
              IF x.u.n»«newline(indent)» «ELSE» «ENDIF»«
            ENDIF»«
          ENDIF»«
        ENDFOR»«
        IF loop.e !== null»|«compile(indent,0,lhs,loop.e,insideWhere,scope)» «ENDIF»repeat «
        IF loop.b !== null»«
          compile(indent,precedence,lhs,loop.b,insideWhere,scope)»«
        ENDIF»'''

/*
 * Do:
 * 'do' b=Block
 */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Do do1,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,do1,null);
	    parent.addSubscope(ns);
        if (do1.e !== null) setNamespace(ns,0,do1.e,insideWhere,RefType.InsideFunction);
        return ns;
    }

/*
 * Do:
 * 'do' b=Block
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,Do do1,WhereState insideWhere,NamespaceScope parentScope)
        '''
        «val NamespaceScope scope =parentScope.getScope(do1)
        »do «IF do1.e !== null»«compile(indent,0,lhs,do1.e,insideWhere,scope)»«ENDIF»'''

    /**
     * Where
     * 
     * The namespace in the 'Where' is in its original position
     * but we also want to move the code outside the function.
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Where where,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(null,where,null);
	  parent.addSubscope(ns);
	  if (where.b !== null) {
	  	//var NamespaceScope whereNamespace = setNamespace(ns,0,where.b,insideWhere,RefType.InsideFunction);
	  	//if (insideWhere != WhereState.WritingWhere) pendingWheres.add(whereNamespace)
	  }
	  return ns;
    }

    /**
     * Where */
	def CharSequence compileExports(int indent,int precedence,Where where,WhereState insideWhere,NamespaceScope parentScope) {
	    if ((where.b !== null)&& insideWhere != WhereState.WritingWhere) pendingWheres.add(new UseMarkerScope(parentScope,where,null,parentScope))
        return "";
        }
/*
 * Where:
 * 'where' b=Block
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,Where where,WhereState insideWhere,NamespaceScope parentScope)
        '''
        «val NamespaceScope scope =parentScope.getScope(where)»where «
        IF (where.b !== null) && insideWhere != WhereState.WritingWhere»«
        compile(indent,precedence,lhs,where.b,WhereState.ReadingWhere,scope)»«
        ENDIF»'''

	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Expr expr,WhereState insideWhere,RefType refType) {
        if (expr instanceof WhereExpression) return setNamespace(parent,precedence,expr as WhereExpression,insideWhere,refType);
	    if (expr instanceof IfExpression) return setNamespace(parent,precedence,expr as IfExpression,insideWhere,refType);
	    if (expr instanceof Expression) return setNamespace(parent,precedence,expr as Expression,insideWhere,refType);
	    if (expr instanceof OrExpression) return setNamespace(parent,precedence,expr as OrExpression,insideWhere,refType);
	    if (expr instanceof AndExpression) return setNamespace(parent,precedence,expr as AndExpression,insideWhere,refType);
	    if (expr instanceof EqualityExpression) return setNamespace(parent,precedence,expr as EqualityExpression,insideWhere,refType);
	    if (expr instanceof RelationalExpression) return setNamespace(parent,precedence,expr as RelationalExpression,insideWhere,refType);
	    if (expr instanceof IsExpression) return setNamespace(parent,precedence,expr as IsExpression,insideWhere,refType);
	    if (expr instanceof InExpression) return setNamespace(parent,precedence,expr as InExpression,insideWhere,refType);
        if (expr instanceof SegmentExpression) return setNamespace(parent,precedence,expr as SegmentExpression,insideWhere,refType);
        if (expr instanceof AdditiveExpression) return setNamespace(parent,precedence,expr as AdditiveExpression,insideWhere,refType);
        if (expr instanceof ExquoExpression) return setNamespace(parent,precedence,expr as ExquoExpression,insideWhere,refType);
        if (expr instanceof DivisionExpression) return setNamespace(parent,precedence,expr as DivisionExpression,insideWhere,refType);
        if (expr instanceof QuoExpression) return setNamespace(parent,precedence,expr as QuoExpression,insideWhere,refType);
        if (expr instanceof ModExpression) return setNamespace(parent,precedence,expr as ModExpression,insideWhere,refType);
        if (expr instanceof RemExpression) return setNamespace(parent,precedence,expr as RemExpression,insideWhere,refType);
        if (expr instanceof MultiplicativeExpression) return setNamespace(parent,precedence,expr as MultiplicativeExpression,insideWhere,refType);
        if (expr instanceof ExponentExpression) return setNamespace(parent,precedence,expr as ExponentExpression,insideWhere,refType);
        if (expr instanceof MapExpression) return setNamespace(parent,precedence,expr as MapExpression,insideWhere,refType);
	    if (expr instanceof LambdaExpression) return setNamespace(parent,precedence,expr as LambdaExpression,insideWhere,refType);
	    if (expr instanceof AssignExpression) return setNamespace(parent,precedence,expr as AssignExpression,insideWhere,refType);
	    if (expr instanceof ExitExpression) return setNamespace(parent,precedence,expr as ExitExpression,insideWhere,refType);
        if (expr instanceof EltExpression) return setNamespace(parent,precedence,expr as EltExpression,insideWhere,refType);
        if (expr instanceof UnaryExpression) return setNamespace(parent,precedence,expr as UnaryExpression,insideWhere,refType);
	    if (expr instanceof VarOrFunction) return setNamespace(parent,precedence,expr as VarOrFunction,insideWhere,refType);
	    if (expr instanceof Tuple) return setNamespace(parent,precedence,expr as Tuple,insideWhere,refType);
	    if (expr instanceof Block) return setNamespace(parent,precedence,expr as Block,insideWhere,refType);
	    if (expr instanceof Literal) return setNamespace(parent,precedence,expr as Literal,insideWhere,refType);
        if (expr.b1 !== null) return setNamespace(parent,precedence,expr.b1,insideWhere,refType);
        if (expr.b2 !== null) return setNamespace(parent,precedence,expr.b2,insideWhere,refType);
        if (expr.b2i !== null) return setNamespace(parent,precedence,expr.b2i,insideWhere,refType);
        if (expr.b3 !== null) return setNamespace(parent,precedence,expr.b3,insideWhere,refType);
        return new NullScope(null,null,null);
    }

	def CharSequence compileExports(int indent,int precedence,Expr expr,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «IF expr instanceof WhereExpression»«compileExports(indent,precedence,expr as WhereExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof VarOrFunction»«compileExports(indent,precedence,expr as VarOrFunction,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof AssignExpression»«compileExports(indent,precedence,expr as AssignExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof LambdaExpression»«compileExports(indent,precedence,expr as LambdaExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof ExitExpression»«compileExports(indent,precedence,expr as ExitExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof Block»«compileExports(indent,precedence,expr as Block,insideWhere,parentScope)»«ENDIF»'''

/* Expr holds both Expression and WhereExpression
 * 
 * WhereExpression returns Expr:
	(Expression ({WhereExpression.left=current} w=Where)?)
	|
	c?=KW_OCURLY (st+=Statement NL)*  KW_CCURLY (KW_EXIT eexp=Expression)?
	|
	(
	    'if' b1=InnerBlock
	    (
          =>('then' b2i=InnerBlock 'else' b3=Block) |
          ('then' b2=Block)
        )	
	)
 * 
 * the eexp is for i-syscmd in function dewritify
 *
	
PrimaryExpression returns Expr:
  (
	Literal
	| p?=KW_OPAREN m?=KW_MINUS? (t4=WhereExpression (KW_COMMA t5+=WhereExpression)*)?
    (
	b?=BEGIN
		(s+=Statement NL)*
	END NL
	)? KW_CPAREN
	|
	c2?=KW_OCURLY BEGIN (s+=Statement NL)* END NL KW_CCURLY
  )
  d=KW_2DOT? // for segment with no end part
  * 
  * from PrimaryExpression - no indent:
  * t4 is WhereExpression inside parenthesis
  * t5 is WhereExpressions inside parenthesis after comma
  * from PrimaryExpression - indent:
  * b=true
  */
	def CharSequence compile(int indent,int precedence,boolean lhs,Expr expr,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «IF expr instanceof WhereExpression»«compile(indent,precedence,lhs,expr as WhereExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof IfExpression»«compile(indent,precedence,lhs,expr as IfExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof Expression»«compile(indent,precedence,lhs,expr as Expression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof OrExpression»«compile(indent,precedence,lhs,expr as OrExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof AndExpression»«compile(indent,precedence,lhs,expr as AndExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof EqualityExpression»«compile(indent,precedence,lhs,expr as EqualityExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof RelationalExpression»«compile(indent,precedence,lhs,expr as RelationalExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof IsExpression»«compile(indent,precedence,lhs,expr as IsExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof InExpression»«compile(indent,precedence,lhs,expr as InExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof SegmentExpression»«compile(indent,precedence,lhs,expr as SegmentExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof AdditiveExpression»«compile(indent,precedence,lhs,expr as AdditiveExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof ExquoExpression»«compile(indent,precedence,lhs,expr as ExquoExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof DivisionExpression»«compile(indent,precedence,lhs,expr as DivisionExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof QuoExpression»«compile(indent,precedence,lhs,expr as QuoExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof ModExpression»«compile(indent,precedence,lhs,expr as ModExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof RemExpression»«compile(indent,precedence,lhs,expr as RemExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof MultiplicativeExpression»«compile(indent,precedence,lhs,expr as MultiplicativeExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof ExponentExpression»«compile(indent,precedence,lhs,expr as ExponentExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof MapExpression»«compile(indent,precedence,lhs,expr as MapExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof LambdaExpression»«compile(indent,precedence,lhs,expr as LambdaExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof AssignExpression»«compile(indent,precedence,lhs,expr as AssignExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof ExitExpression»«compile(indent,precedence,lhs,expr as ExitExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof EltExpression»«compile(indent,precedence,lhs,expr as EltExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof UnaryExpression»«compile(indent,precedence,lhs,expr as UnaryExpression,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof VarOrFunction»«compile(indent,precedence,lhs,expr as VarOrFunction,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof Tuple»«compile(indent,precedence,lhs,expr as Tuple,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof Block»«compile(indent,precedence,lhs,expr as Block,insideWhere,parentScope)»«ENDIF»«
	    IF expr instanceof Literal»«compile(indent,precedence,lhs,expr as Literal,insideWhere,parentScope)»«ENDIF»«
	    IF expr.b1 !== null»if «
	      compile(indent,precedence,lhs,expr.b1,insideWhere,parentScope)»«
	      IF expr.n1»«newline(indent)»«ELSE» «ENDIF»«
	    ENDIF»«
	    IF expr.b2 !== null»then «
	      compile(indent,precedence,lhs,expr.b2,insideWhere,parentScope)» «
	    ENDIF»«
	    IF expr.b2i !== null»then «
	      compile(indent,precedence,lhs,expr.b2i,insideWhere,parentScope)»«
	      IF expr.n2»«newline(indent)»«ELSE» «ENDIF»«
	    ENDIF»«
	    IF expr.b3 !== null»else «
	      compile(indent,precedence,lhs,expr.b3,insideWhere,parentScope)»«ENDIF»'''

    /** WhereExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,WhereExpression whereExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,whereExpression,null);
	  parent.addSubscope(ns);
      if (whereExpression.left !== null) setNamespace(ns,1,whereExpression.left,insideWhere,RefType.InsideFunction);
	  if (whereExpression.w !== null) setNamespace(ns,1,whereExpression.w,insideWhere,RefType.InsideFunction);
	  return ns;
    }

	def CharSequence compileExports(int indent,int precedence,WhereExpression whereExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(whereExpression)»«
        IF whereExpression.left !== null»«compileExports(indent,1,whereExpression.left,insideWhere,scope)»«ENDIF»«
	    IF whereExpression.w !== null» «compileExports(indent,1,whereExpression.w,insideWhere,scope)» «ENDIF»'''

/* WhereExpression returns Expr:
	(Expression ({WhereExpression.left=current} w=Where?))
	|
	c?=KW_OCURLY (st+=Statement NL)* KW_CCURLY
	|
	(
	    'if' b1=InnerBlock
	    (
          =>('then' b2i=InnerBlock 'else' b3=Block) |
          ('then' b2=Block)
        )	
	)
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,WhereExpression whereExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(whereExpression)»«
        IF whereExpression.left !== null»«compile(indent,1,lhs,whereExpression.left,insideWhere,scope)»«ENDIF»«
	    IF whereExpression.w !== null» «compile(indent,1,lhs,whereExpression.w,insideWhere,scope)» «ENDIF»'''

    /**
     * IfExpression 
     * IfExpression returns Expr:
     * Expression
     * |
     * ({IfExpression} KW_AT 'if' i1=Expression 'then' i2=Statement NL? ('else' i3=Statement NL?)? KW_AT)
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,IfExpression ifExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,ifExpression,null);
	  parent.addSubscope(ns);
      if(ifExpression.i1 !== null) setNamespace(ns,0,ifExpression.i1,insideWhere,RefType.InsideFunction);
      if(ifExpression.i2 !== null) setNamespace(ns,0,ifExpression.i2,insideWhere,RefType.InsideFunction);
      if(ifExpression.i3 !== null) setNamespace(ns,0,ifExpression.i3,insideWhere,RefType.InsideFunction);
      return ns;
    }

    /**
     * IfExpression 
     * IfExpression returns Expr:
     * Expression
     * |
     * ({IfExpression} KW_AT 'if' i1=Expression 'then' i2=Statement NL? ('else' i3=Statement NL?)? KW_AT)
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,IfExpression ifExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(ifExpression)»«
        IF ifExpression.i1 !== null»if «compile(indent,0,lhs,ifExpression.i1,insideWhere,scope)» «ENDIF»«
        IF ifExpression.i2 !== null»then «compile(indent,0,lhs,ifExpression.i2,insideWhere,scope)» «ENDIF»«
        IF ifExpression.i3 !== null»«
          newline(indent)»else «
          compile(indent,0,lhs,ifExpression.i3,insideWhere,scope)» «
        ENDIF»'''

/* Expression
 * This is top of expression tree except for WhereExpression
 * combines statements using semicolon
 */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Expression expression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,expression,null);
	  parent.addSubscope(ns);
	  if(expression.left !== null) setNamespace(ns,8,expression.left,insideWhere,RefType.InsideFunction);
	  if(expression.right !== null) setNamespace(ns,8,expression.right,insideWhere,RefType.InsideFunction);
	  if(expression.right2 !== null) setNamespace(ns,8,expression.right2,insideWhere,RefType.InsideFunction);
	  return ns;
	}

/* Expression
 * This is top of expression tree except for WhereExpression
 * combines statements using semicolon
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,Expression expression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(expression)»«
        cop(8,precedence)»«
	    IF expression.left !== null»«compile(indent,8,lhs,expression.left,insideWhere,scope)»«ENDIF»«
	    IF expression.op !== null» «expression.op» «ENDIF»«
	    IF expression.right !== null»«compile(indent,8,lhs,expression.right,insideWhere,scope)»«ENDIF»«
	    IF expression.right2 !== null»«compile(indent,8,lhs,expression.right2,insideWhere,scope)»«ENDIF»«
	    ccp(8,precedence)»'''

	def CharSequence compile(int indent,int precedence,boolean lhs,MapExpression mapExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(mapExpression)»«
        cop(10,precedence)»«
	    IF mapExpression.left !== null»«compile(indent,10,lhs,mapExpression.left,insideWhere,scope)»«ENDIF»«
	    IF mapExpression.op !== null» «mapExpression.op» «ENDIF»«
	    IF mapExpression.right !== null»«compile(indent,10,lhs,mapExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(10,precedence)»'''

    /** LambdaExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,LambdaExpression lambdaExpression,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,lambdaExpression,null);
	    parent.addSubscope(ns);
        var VarOrFunction v =null;
        var fnName="";
        if (lambdaExpression.left !== null) {
          if (lambdaExpression.left instanceof VarOrFunction) {
            v=lambdaExpression.left as VarOrFunction
            	fnName=v.name
            	while (!vars.addFunctionDef(fnName,currentFunction,currentFile,bootPkg,null,0)) fnName=fnName+"2";
          }
        }
        return ns;
    }

	def CharSequence compileExports(int indent,int precedence,LambdaExpression lambdaExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(lambdaExpression)»«
        var VarOrFunction v =null»«
        var fnName=""»«
        IF lambdaExpression.left !== null»«
          IF lambdaExpression.left instanceof VarOrFunction»«
            {v=lambdaExpression.left as VarOrFunction
            	//fnName=v.name
            	//while (!vars.addFunction(fnName,currentFunction,currentFile,null)) fnName=fnName+"2";
            	null;
            }»«
            newline(indent-1)»«
            currentFunction»«
            fnName»«
            IF v.expr !== null»«
              IF v.expr instanceof Tuple»«
                compile(indent,10,false,(v.expr as Tuple),insideWhere,scope)»«
              ENDIF»«
            ENDIF»«
          ENDIF»«
        ENDIF»'''

	def CharSequence compile(int indent,int precedence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere,NamespaceScope parentScope) {
	  switch insideWhere {
	  	case NotWhere : return compileNotInside(indent,precedence,lhs,lambdaExpression,insideWhere,parentScope)
	  	case ReadingWhere : return compileRead(indent,precedence,lhs,lambdaExpression,insideWhere,parentScope)
	  	case WritingWhere : return compileWrite(indent,precedence,lhs,lambdaExpression,insideWhere,parentScope)
	  }
	  return "";
    }
    
	def CharSequence compileNotInside(int indent,int precedence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(lambdaExpression)»«
        cop(12,precedence)»«
	    IF lambdaExpression.left !== null»«compile(indent,12,lhs,lambdaExpression.left,insideWhere,scope)»«ENDIF»«
	    IF lambdaExpression.op !== null» +-> «ENDIF»«
	    IF lambdaExpression.right !== null»«compile(indent,12,lhs,lambdaExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(12,precedence)»'''

	def CharSequence compileRead(int indent,int precedence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere,NamespaceScope parentScope) {
		pendingLambda.add(lambdaExpression);
		return "";
	}

	def CharSequence compileWrite(int indent,int precedence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere,NamespaceScope parentScope)
		'''
	    «val NamespaceScope scope =parentScope.getScope(lambdaExpression)»«
        newline(indent)»«
	    IF lambdaExpression.left !== null»«currentFunction»«compile(indent,12,lhs,lambdaExpression.left,insideWhere,scope)»«ENDIF»«
	    IF lambdaExpression.op !== null» == «ENDIF»«
	    IF lambdaExpression.right !== null»«compile(indent,12,lhs,lambdaExpression.right,insideWhere,scope)»«ENDIF»«
		newline(indent)»'''

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ExitExpression exitExpression,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,exitExpression,null);
	    parent.addSubscope(ns);
        if (exitExpression.left !== null) setNamespace(ns,14,exitExpression.left,insideWhere,RefType.InsideFunction);
	    if (exitExpression.right !== null) setNamespace(ns,14,exitExpression.right,insideWhere,RefType.InsideFunction);
	    return ns;
    }

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def CharSequence compileExports(int indent,int precedence,ExitExpression exitExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(exitExpression)»«
        IF exitExpression.left !== null»«compileExports(indent,14,exitExpression.left,insideWhere,scope)»«ENDIF»«
	    IF exitExpression.right !== null»«compileExports(indent,14,exitExpression.right,insideWhere,scope)»«ENDIF»'''

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,ExitExpression exitExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(exitExpression)»«
        cop(14,precedence)»«
	    IF exitExpression.left !== null»«compile(indent,14,lhs,exitExpression.left,insideWhere,scope)»«ENDIF»«
	    IF exitExpression.op !== null» «exitExpression.op» «ENDIF»«
	    IF exitExpression.right !== null»«compile(indent,14,lhs,exitExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(14,precedence)»'''

    /**
     * AssignExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,AssignExpression assignExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,assignExpression,null);
	  parent.addSubscope(ns);
      if (assignExpression.left !== null) {
          if (assignExpression.left instanceof VarOrFunction) {
          	val VarOrFunction v = assignExpression.left as VarOrFunction;
          	vars.addWrite(v.name,currentFunction);
          }
          if (assignExpression.left instanceof ListLiteral) {
            val ListLiteral ll = (assignExpression.left as ListLiteral);
	        val ListTree lt = new ListTree(ll,new ArrayList<Integer>());
	        val ArrayList<String> vs = lt.variables();
	        for (String v:vs) {
	     	  vars.addWrite(v,currentFunction);
	        }
          }
	      //setNamespace(ns,16,assignExpression.left,insideWhere,RefType.VarWrite);
	  }
	  if (assignExpression.right !== null) {
	      setNamespace(ns,16,assignExpression.right,insideWhere,RefType.VarRead);
	  }
	  return ns;
	}

    /**
     * AssignExpression */
	def CharSequence compileExports(int indent,int precedence,AssignExpression assignExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(assignExpression)»«
        IF assignExpression.left !== null»«
	      compileExports(indent,16,assignExpression.left,insideWhere,scope)»«
	    ENDIF»«
	    IF assignExpression.right !== null»«
	      compileExports(indent,16,assignExpression.right,insideWhere,scope)»«
	    ENDIF»'''

    /**
     * AssignExpression */
	def CharSequence compile(int indent,int precedence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere,NamespaceScope parentScope) {
		val NamespaceScope scope =parentScope.getScope(assignExpression);
	    if (insideWhere!=WhereState.NotWhere) {return 
          '''
          «IF assignExpression.left !== null»«compile(indent,16,lhs,assignExpression.left,insideWhere,scope)» := «ENDIF»«
          IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere,scope)»«ENDIF»'''
        }
	    if (assignExpression.left !== null) {
	      if (assignExpression.left instanceof VarOrFunction)
	        return compileAssignSingle(indent,precedence,lhs,assignExpression,insideWhere,parentScope);
	      if (assignExpression.left instanceof ListLiteral)
	        return compileAssignList(indent,precedence,lhs,assignExpression,insideWhere,parentScope);
	      if (assignExpression.left instanceof AssignExpression)
	        return compileAssignAsign(indent,precedence,lhs,assignExpression,insideWhere,parentScope);
	    }
	    return " error cannot assign this:"+assignExpression
    }

   /**
    * nested AssignExpression 
    */
	def CharSequence compileAssignAsign(int indent,int precedence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere,NamespaceScope parentScope) '''
	    «val NamespaceScope scope =parentScope.getScope(assignExpression)»«
        cop(16,precedence)»«
	    compile(indent,16,true,assignExpression.left as AssignExpression,insideWhere,scope)»«
	    IF assignExpression.op !== null» «assignExpression.op» «ENDIF»«
	    IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere,scope)»«ENDIF»«
	    cop(16,precedence)»'''
	    
    /**
     * AssignExpression 
     * where left is a single variable */
	def CharSequence compileAssignSingle(int indent,int precedence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere,NamespaceScope parentScope) '''
	    «val NamespaceScope scope =parentScope.getScope(assignExpression)»«
        cop(16,precedence)»«
	    var String nam="unknown"»«
	    var boolean dynamic=false»«
	    var VarOrFunction v»«
        {v = (assignExpression.left as VarOrFunction);
	    nam = v.name;
	    if (v.expr instanceof UnaryExpression) dynamic= (v.expr as UnaryExpression).loc;
	    null}»«
	    IF vars.isGlobalsWritten(nam,currentFunction)»putVar(bootEnvir,"«nam»",«
	      compile(indent,16,lhs,assignExpression.left,insideWhere,scope)» := «
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere,scope)»«ENDIF»)«
        ELSE»«
	      compile(indent,16,true,assignExpression.left,insideWhere,scope)»«
	      IF assignExpression.op !== null» «assignExpression.op» «ENDIF»«
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere,scope)»«ENDIF»«
        ENDIF»«
	    cop(16,precedence)»'''

    /**
     * AssignExpression
     * where left is a list containing variables */
	def CharSequence compileAssignList(int indent,int precedence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(assignExpression)»«
        cop(16,precedence)»«
	    var ListLiteral ll»«
	    var ListTree lt»«
	    var String listName = "listTree"»«
	    {ll = (assignExpression.left as ListLiteral);
	     lt = new ListTree(ll,new ArrayList<Integer>());
	     null;
	    }»«
	    »listTree:SExpression := «
	    IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere,scope)»«ENDIF»«
	    FOR x:lt.output(listName,":SExpression")»«
	      newline(indent)»«x»«
	    ENDFOR»«
	    cop(16,precedence)»'''

    /**
     * OrExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,OrExpression orExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,orExpression,null);
	  parent.addSubscope(ns);
	  if(orExpression.left !== null) setNamespace(ns,18,orExpression.left,insideWhere,RefType.InsideFunction);
	  if(orExpression.right !== null) setNamespace(ns,18,orExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

    /**
     * OrExpression */
	def CharSequence compile(int indent,int precedence,boolean lhs,OrExpression orExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(orExpression)»«
        cop(18,precedence)»«
	    IF orExpression.left !== null»«compile(indent,18,lhs,orExpression.left,insideWhere,scope)»«ENDIF»«
	    IF orExpression.op !== null» «orExpression.op» «ENDIF»«
	    IF orExpression.right !== null»«compile(indent,18,lhs,orExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(18,precedence)»'''

    /**
     * AndExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,AndExpression andExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,andExpression,null);
	  parent.addSubscope(ns);
	  if(andExpression.left !== null) setNamespace(ns,20,andExpression.left,insideWhere,RefType.InsideFunction);
	  if(andExpression.right !== null) setNamespace(ns,20,andExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

    /**
     * AndExpression */
	def CharSequence compile(int indent,int precedence,boolean lhs,AndExpression andExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(andExpression)»«
        cop(20,precedence)»«
	    IF andExpression.left !== null»«compile(indent,20,lhs,andExpression.left,insideWhere,scope)»«ENDIF»«
	    IF andExpression.op !== null» «andExpression.op» «ENDIF»«
	    IF andExpression.right !== null»«compile(indent,20,lhs,andExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(20,precedence)»'''

    /**
     * EqualityExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,EqualityExpression equalityExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,equalityExpression,null);
	  parent.addSubscope(ns);
	  if(equalityExpression.left !== null) setNamespace(ns,20,equalityExpression.left,insideWhere,RefType.InsideFunction);
	  if(equalityExpression.right !== null) setNamespace(ns,20,equalityExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

 	def CharSequence compile(int indent,int precedence,boolean lhs,EqualityExpression equalityExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(equalityExpression)»«
        cop(22,precedence)»«
	    IF equalityExpression.left !== null»«compile(indent,22,lhs,equalityExpression.left,insideWhere,scope)»«ENDIF»«
	    IF equalityExpression.op !== null» «equalityExpression.op» «ENDIF»«
	    IF equalityExpression.right !== null»«compile(indent,22,lhs,equalityExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(22,precedence)»'''

    /**
     * RelationalExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,RelationalExpression relationalExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,relationalExpression,null);
	  parent.addSubscope(ns);
	  if(relationalExpression.left !== null) setNamespace(ns,20,relationalExpression.left,insideWhere,RefType.InsideFunction);
	  if(relationalExpression.right !== null) setNamespace(ns,20,relationalExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,RelationalExpression relationalExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(relationalExpression)»«
        cop(24,precedence)»«
	    IF relationalExpression.left !== null»«compile(indent,24,lhs,relationalExpression.left,insideWhere,scope)»«ENDIF»«
	    IF relationalExpression.op !== null» «relationalExpression.op» «ENDIF»«
	    IF relationalExpression.right !== null»«compile(indent,24,lhs,relationalExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(24,precedence)»'''

    /**
     * IsExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,IsExpression isExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(null,isExpression,null);
	  parent.addSubscope(ns);
	  if(isExpression.left !== null)
	      setNamespace(ns,26,isExpression.left,insideWhere,RefType.InsideFunction);
	  if(isExpression.right !== null) {
          if (isExpression.right instanceof ListLiteral) {
            val ListLiteral ll = (isExpression.right as ListLiteral);
	        val ListTree lt = new ListTree(ll,new ArrayList<Integer>());
	        val ArrayList<String> vs = lt.variables();
	        for (String v:vs) {
	     	  vars.addWrite(v,currentFunction);
	        }
          }
          setNamespace(ns,26,isExpression.right,insideWhere,RefType.InsideFunction);
      }
      return ns;
	}

    /**
     * IsExpression */
	def CharSequence compile(int indent,int precedence,boolean lhs,IsExpression isExpression,WhereState insideWhere,NamespaceScope parentScope) {
	    if (isExpression.right !== null) {
	      if (isExpression.right instanceof ListLiteral) {
	        return compileIsList(indent,precedence,lhs,isExpression,insideWhere,parentScope);
	      }
	      return compileIsSingle(indent,precedence,lhs,isExpression,insideWhere,parentScope);	      	
	    }
    }

    /**
     * IsExpression */
	def CharSequence compileIsSingle(int indent,int precedence,boolean lhs,IsExpression isExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(isExpression)»«
        cop(26,precedence)»«
	    IF isExpression.left !== null»«
	      compile(indent,26,lhs,isExpression.left,insideWhere,scope)»«ENDIF»«
	    IF isExpression.op !== null» «isExpression.op» «ENDIF»«
	    IF isExpression.right !== null»«
	      compile(indent,26,true,isExpression.right,insideWhere,scope)»«
	    ENDIF»«
	    ccp(26,precedence)»'''

    /**
     * IsExpression
     * where right is a list containing variables */
	def CharSequence compileIsList(int indent,int precedence,boolean lhs,IsExpression isExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(isExpression)»«
        cop(16,precedence)»«
	    var ListLiteral ll»«
	    var ListTree lt»«
	    var String listName = "listTree"»«
	    IF isExpression.left !== null»«
	      compile(indent,16,lhs,isExpression.left,insideWhere,scope)»«
	      IF isExpression.left instanceof VarOrFunction »«
          	{val VarOrFunction v = isExpression.left as VarOrFunction;
          	listName = v.name;null}»«
          ENDIF»«
	    ENDIF»«
	    IF isExpression.right !== null»«
	    {ll = (isExpression.right as ListLiteral);
	     lt = new ListTree(ll,new ArrayList<Integer>());
	     null;
	    }»«
	    » = «
	    compile(indent,16,lhs,isExpression.right,insideWhere,scope)»«ENDIF»«
	    {pendingStatements = lt.output(listName,":SExpression");null}»«
	    cop(16,precedence)»'''

    /**
     * InExpression
     */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,InExpression inExpression,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,inExpression,null);
	    parent.addSubscope(ns);
	    if(inExpression.left !== null)
          if (inExpression.left instanceof VarOrFunction) {
          	val VarOrFunction v = inExpression.left as VarOrFunction;
          	vars.addWrite(v.name,currentFunction);
          }
	      setNamespace(ns,28,inExpression.left,insideWhere,RefType.InsideFunction);
	    if(inExpression.right !== null) setNamespace(ns,28,inExpression.right,insideWhere,RefType.InsideFunction);
	    if(inExpression.r2 !== null) setNamespace(ns,29,inExpression.r2,insideWhere,RefType.InsideFunction);
	    return ns;
	}

    /**
     * InExpression
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,InExpression inExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(inExpression)»«
        cop(28,precedence)»«
	    IF inExpression.left !== null»«
	      compile(indent,28,true,inExpression.left,insideWhere,scope)»«
	    ENDIF»«
	    IF inExpression.op !== null» «inExpression.op» «ENDIF»«
	    IF inExpression.right !== null»«compile(indent,28,lhs,inExpression.right,insideWhere,scope)»«ENDIF»«
	    IF inExpression.r2 !== null» by «compile(indent,29,lhs,inExpression.r2,insideWhere,scope)»«ENDIF»«
	    ccp(28,precedence)»'''
	
    /**
     * SegmentExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,SegmentExpression segmentExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,segmentExpression,null);
	  parent.addSubscope(ns);
	  if(segmentExpression.left !== null)
	      setNamespace(ns,30,segmentExpression.left,insideWhere,RefType.InsideFunction);
	  if(segmentExpression.right !== null)
	      setNamespace(ns,30,segmentExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	/*
	 * ..
	 * don't put spaces around segment */ 
	def CharSequence compile(int indent,int precedence,boolean lhs,SegmentExpression segmentExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(segmentExpression)»«
        cop(30,precedence)»«
	    IF segmentExpression.left !== null»«compile(indent,30,lhs,segmentExpression.left,insideWhere,scope)»«ENDIF»«
	    IF segmentExpression.op !== null»«segmentExpression.op»«ENDIF»«
	    IF segmentExpression.right !== null»«compile(indent,30,lhs,segmentExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(30,precedence)»'''

    /**
     * AdditiveExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,AdditiveExpression additiveExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,additiveExpression,null);
	  parent.addSubscope(ns);
	  if(additiveExpression.left !== null)
	      setNamespace(ns,32,additiveExpression.left,insideWhere,RefType.InsideFunction);
	  if(additiveExpression.right !== null)
	      setNamespace(ns,32,additiveExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,AdditiveExpression additiveExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(additiveExpression)»«
        cop(32,precedence)»«
	    IF additiveExpression.left !== null»«compile(indent,32,lhs,additiveExpression.left,insideWhere,scope)»«ENDIF»«
	    IF additiveExpression.op !== null» «additiveExpression.op» «ENDIF»«
	    IF additiveExpression.right !== null»«compile(indent,32,lhs,additiveExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(32,precedence)»'''

    /**
     * ExquoExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ExquoExpression exquoExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,exquoExpression,null);
	  parent.addSubscope(ns);
	  if(exquoExpression.left !== null)
	      setNamespace(ns,34,exquoExpression.left,insideWhere,RefType.InsideFunction);
	  if(exquoExpression.right !== null)
	      setNamespace(ns,34,exquoExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,ExquoExpression exquoExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(exquoExpression)»«
        cop(34,precedence)»«
	    IF exquoExpression.left !== null»«compile(indent,34,lhs,exquoExpression.left,insideWhere,scope)»«ENDIF»«
	    IF exquoExpression.op !== null» «exquoExpression.op» «ENDIF»«
	    IF exquoExpression.right !== null»«compile(indent,34,lhs,exquoExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(34,precedence)»'''

    /**
     * DivisionExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,DivisionExpression divisionExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,divisionExpression,null);
	  parent.addSubscope(ns);
	  if(divisionExpression.left !== null)
	      setNamespace(ns,36,divisionExpression.left,insideWhere,RefType.InsideFunction);
	  if(divisionExpression.right !== null)
	      setNamespace(ns,36,divisionExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,DivisionExpression divisionExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(divisionExpression)»«
        cop(36,precedence)»«
	    IF divisionExpression.left !== null»«compile(indent,36,lhs,divisionExpression.left,insideWhere,scope)»«ENDIF»«
	    IF divisionExpression.op !== null» «divisionExpression.op» «ENDIF»«
	    IF divisionExpression.right !== null»«compile(indent,36,lhs,divisionExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(363,precedence)»'''

    /**
     * QuoExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,QuoExpression quoExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,quoExpression,null);
	  parent.addSubscope(ns);
	  if(quoExpression.left !== null)
	      setNamespace(ns,16,quoExpression.left,insideWhere,RefType.InsideFunction);
	  if(quoExpression.right !== null)
	      setNamespace(ns,16,quoExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,QuoExpression quoExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(quoExpression)»«
        cop(16,precedence)»«
	    IF quoExpression.left !== null»«compile(indent,16,lhs,quoExpression.left,insideWhere,scope)»«ENDIF»«
	    IF quoExpression.op !== null» «quoExpression.op» «ENDIF»«
	    IF quoExpression.right !== null»«compile(indent,16,lhs,quoExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(16,precedence)»'''

    /**
     * ModExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ModExpression modExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,modExpression,null);
	  parent.addSubscope(ns);
	  if(modExpression.left !== null)
	      setNamespace(ns,38,modExpression.left,insideWhere,RefType.InsideFunction);
	  if(modExpression.right !== null)
	      setNamespace(ns,38,modExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,ModExpression modExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(modExpression)»«
        cop(38,precedence)»«
	    IF modExpression.left !== null»«compile(indent,38,lhs,modExpression.left,insideWhere,scope)»«ENDIF»«
	    IF modExpression.op !== null» «modExpression.op» «ENDIF»«
	    IF modExpression.right !== null»«compile(indent,38,lhs,modExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(38,precedence)»'''

    /**
     * RemExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,RemExpression remExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,remExpression,null);
	  parent.addSubscope(ns);
	  if(remExpression.left !== null)
	      setNamespace(ns,40,remExpression.left,insideWhere,RefType.InsideFunction);
	  if(remExpression.right !== null)
	      setNamespace(ns,40,remExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,RemExpression remExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(remExpression)»«
        cop(40,precedence)»«
	    IF remExpression.left !== null»«compile(indent,40,lhs,remExpression.left,insideWhere,scope)»«ENDIF»«
	    IF remExpression.op !== null» «remExpression.op» «ENDIF»«
	    IF remExpression.right !== null»«compile(indent,40,lhs,remExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(40,precedence)»'''

    /**
     * MultiplicativeExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,MultiplicativeExpression multiplicativeExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,multiplicativeExpression,null);
	  parent.addSubscope(ns);
	  if(multiplicativeExpression.left !== null)
	      setNamespace(ns,42,multiplicativeExpression.left,insideWhere,RefType.InsideFunction);
	  if(multiplicativeExpression.right !== null)
	      setNamespace(ns,42,multiplicativeExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,MultiplicativeExpression multiplicativeExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(multiplicativeExpression)»«
        cop(42,precedence)»«
	    IF multiplicativeExpression.left !== null»«compile(indent,42,lhs,multiplicativeExpression.left,insideWhere,scope)»«ENDIF»«
	    IF multiplicativeExpression.op !== null» «multiplicativeExpression.op»«ENDIF»«
	    IF multiplicativeExpression.right !== null»«compile(indent,42,lhs,multiplicativeExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(42,precedence)»'''

    /**
     * ExponentExpression  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ExponentExpression exponentExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,exponentExpression,null);
	  parent.addSubscope(ns);
	  if(exponentExpression.left !== null)
	      setNamespace(ns,44,exponentExpression.left,insideWhere,RefType.InsideFunction);
	  if(exponentExpression.right !== null)
	      setNamespace(ns,44,exponentExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,ExponentExpression exponentExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(exponentExpression)»«
        cop(44,precedence)»«
	    IF exponentExpression.left !== null»«compile(indent,44,lhs,exponentExpression.left,insideWhere,scope)»«ENDIF»«
	    IF exponentExpression.op !== null»«exponentExpression.op» «ENDIF»«
	    IF exponentExpression.right !== null»«compile(indent,44,lhs,exponentExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(44,precedence)»'''

    /**
     * EltExpression  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,EltExpression eltExpression,WhereState insideWhere,RefType refType){
	  val NamespaceScope ns = new NamespaceScope(parent,eltExpression,null);
	  parent.addSubscope(ns);
	  if(eltExpression.left !== null)
	      setNamespace(ns,46,eltExpression.left,insideWhere,RefType.InsideFunction);
	  if(eltExpression.right !== null)
	      setNamespace(ns,46,eltExpression.right,insideWhere,RefType.InsideFunction);
	  return ns;
	}

	def CharSequence compile(int indent,int precedence,boolean lhs,EltExpression eltExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(eltExpression)»«
        cop(46,precedence)»«
	    IF eltExpression.left !== null»«compile(indent,46,lhs,eltExpression.left,insideWhere,scope)»«ENDIF»«
	    IF eltExpression.op !== null»«eltExpression.op»«ENDIF»«
	    IF eltExpression.right !== null»«compile(indent,46,lhs,eltExpression.right,insideWhere,scope)»«ENDIF»«
	    ccp(46,precedence)»'''

	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,UnaryExpression unaryExpression,WhereState insideWhere,RefType refType) {
	  val NamespaceScope ns = new NamespaceScope(parent,unaryExpression,null);
	  parent.addSubscope(ns);
	  if (unaryExpression.b1 !== null) setNamespace(ns,48,unaryExpression.b1,insideWhere,RefType.InsideFunction);
	  if (unaryExpression.b3 !== null) setNamespace(ns,48,unaryExpression.b3,insideWhere,RefType.InsideFunction);
	  if (unaryExpression.expr !== null) setNamespace(ns,48,unaryExpression.expr,insideWhere,RefType.InsideFunction);
	  return ns;
	}

/*
 * UnaryExpression returns Expr:
PrimaryExpression |
({UnaryExpression} name=TK_ID =>p2?=KW_PRIME? expr=UnaryExpression?) |
({UnaryExpression} uop='not' expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON expr=UnaryExpression) |
({UnaryExpression} uop='or/' expr=UnaryExpression) |
({UnaryExpression} uop='and/' expr=UnaryExpression) |
({UnaryExpression} uop='+/' expr=UnaryExpression) |
({UnaryExpression} uop='*./' expr=UnaryExpression) | // needs . otherwise causes errors in xtext files
({UnaryExpression} uop='return' expr=UnaryExpression) |
({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON loc?='local')
* 
* Put a space between ID and expr but not $ and expr
* 
*/
	def CharSequence compile(int indent,int precedence,boolean lhs,UnaryExpression unaryExpression,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(unaryExpression)»«
        cop(48,precedence)»«
	    IF unaryExpression.b1 !== null»«compile(indent,48,lhs,unaryExpression.b1,insideWhere,scope)»«ENDIF»«
	    IF unaryExpression.b2 !== null»«unaryExpression.b2»«ENDIF»«
	    IF unaryExpression.b3 !== null»«compile(indent,48,lhs,unaryExpression.b3,insideWhere,scope)»«ENDIF»«
	    IF unaryExpression.uop !== null»«
	      if (unaryExpression.uop.compareTo("*./")==0) "*/" else
            if (unaryExpression.uop.compareTo(":")==0) "" else
	          unaryExpression.uop»«
	      if (unaryExpression.uop.compareTo("not")==0) " "»«
	      if (unaryExpression.uop.compareTo("return")==0) " "»«
	    ENDIF»«
	    IF unaryExpression.expr !== null»«compile(indent,48,lhs,unaryExpression.expr,insideWhere,scope)»«ENDIF»«
	    ccp(48,precedence)»'''

    /**
     * Tuple */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Tuple expr,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,expr,null);
	    parent.addSubscope(ns);
	    for (Statement x:expr.t5)
	        setNamespace(ns,0,x,insideWhere,RefType.InsideFunction);
	    if (expr.t3 !== null)
	        setNamespace(ns,0,expr.t3,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*{Tuple} p?=KW_OPAREN m2?=KW_MINUS? (t3=WhereExpression NL? (KW_COMMA t5+=WhereExpression)*)? */
	def CharSequence compile(int indent,int precedence,boolean lhs,Tuple expr,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(expr)»«
        var Boolean removeBrackets =false»«
 	    IF expr.m2»«
	      IF expr.t3 !== null»«
	        IF expr.t3 instanceof Literal»«{removeBrackets =true;null}»«ENDIF»«
	      ENDIF»«
	    ENDIF»«
	    IF (!removeBrackets) »(«ENDIF»«
	    IF expr.m2»-«ENDIF»«
	    IF expr.t3 !== null»«compile(indent,0,lhs,expr.t3,insideWhere,scope)»«ENDIF»«
	    FOR x:expr.t5»,«compile(indent,0,lhs,x,insideWhere,scope)»«ENDFOR»«
	    IF (!removeBrackets) »)«ENDIF»«
	    IF expr.d»..«ENDIF»'''

    /**
     * Block */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Block expr,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,expr,null);
	    parent.addSubscope(ns);
	    for (Statement x:expr.s)
	        setNamespace(ns,0,x,insideWhere,RefType.InsideFunction);
	    if (expr.t4 !== null)
	        setNamespace(ns,0,expr.t4,insideWhere,RefType.InsideFunction);
	    return ns;
	}

    /**
     * Block */
	def CharSequence compileExports(int indent,int precedence,Block expr,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(expr)»«
        IF expr.b»«
	      FOR x:expr.s»«
	        compileExports(indent+1,0,x,insideWhere,scope)»«
	      ENDFOR»«
	    ENDIF»'''

/*PrimaryExpression returns Expr:
  (
	Literal
	|
	({Tuple} p?=KW_OPAREN m2?=KW_MINUS? (t3=WhereExpression NL? (KW_COMMA t5+=WhereExpression)*)?
    KW_CPAREN)
	|
	({Block} b?=BEGIN
		(s+=Statement NL)*
	END )
	|
	({Block} c2?=KW_OCURLY (s+=Statement NL)* KW_CCURLY )
	|
	({Block} c3?=KW_OCHEV m?=KW_MINUS? t4=WhereExpression KW_CCHEV )
	
  )
  d=KW_2DOT? // for segment with no end part */
	def CharSequence compile(int indent,int precedence,boolean lhs,Block expr,WhereState insideWhere,NamespaceScope parentScope) {
/*  	  if (insideWhere==WhereState.WritingWhere) {
	    if (expr.s === null) return "";
	    var String res = "";
	    for (Object sto:  expr.s.toArray()) {
	  	  var Statement st = sto as Statement;
	  	  //compile(indent+1,0,lhs,st,insideWhere);
	    }
	    return res
	  }*/
	  //try {
	    val NamespaceScope scope =parentScope.getScope(expr);
	    return
	    '''
	    «FOR s:pendingStatements»«
	      newline(indent+1)»«
	      s»«
	    ENDFOR»«
	    {pendingStatements.clear();null}»«
	    IF expr.c2»(«
	      FOR x:expr.s»«
	        newline(indent+1)»«
	        compile(indent+1,0,lhs,x,insideWhere,scope)»«
	      ENDFOR»)«
	    ENDIF»«
	    IF expr.b»«
	      FOR x:expr.s»«
	        newline(indent+1)»«
	        compile(indent+1,0,lhs,x,insideWhere,scope)»«
	      ENDFOR»«
	    ENDIF»«
	    IF expr.c3»«
	      IF expr.m»-«ENDIF»«
	      IF expr.t4 !== null»«compile(indent,0,lhs,expr.t4,insideWhere,scope)»«ENDIF»«
	    ENDIF»«
	    IF expr.d»..«ENDIF»'''
	    
//	    } catch (Exception e) {
//	    	System.err.println("error "+e);
//	    	return "error "+e
//	    }
	}

    /**
     * VarOrFunction  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,VarOrFunction varOrFunction,WhereState insideWhere,RefType refType) {
      var String nam = varOrFunction.name;
	  var NamespaceScope ns = null;
	  var boolean isVar=true;
	  if (varOrFunction.expr !== null) {
	    isVar=false;
        if (varOrFunction.expr instanceof UnaryExpression) {
	      var UnaryExpression u = varOrFunction.expr as UnaryExpression
	      if (u.uop == ":") isVar=true;
	    }
	  }
	  if (isVar) {
	    ns = switch (refType) {
	  	  case Parameter : new ParameterScope(parent,varOrFunction,nam)
	  	  case VarWrite : new LocalVarScope(parent,varOrFunction,nam)
          default : new NamespaceScope(parent,varOrFunction,nam)
        }
        vars.addRead(nam,currentFunction);
	  } else {
	  	ns = new FunctionCallScope(parent,varOrFunction,nam)
      	setNamespace(ns,0,varOrFunction.expr,insideWhere,RefType.InsideFunction);
      	vars.addFunctionCall(nam,varOrFunction.expr,currentFunction,currentFile);
	  }
	  parent.addSubscope(ns);
      return ns;
    }

    /**
     * VarOrFunction  */
	def CharSequence compileExports(int indent,int precedence,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope)''''''

/**
 * VarOrFunction
 * {VarOrFunction} name=TK_ID expr=UnaryExpression?)
 * If expr exists then this is usually a function
 * except if it is UnaryExpression with loc=true
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope) {
	    var boolean isVar=true;
	    if (varOrFunction.expr !== null) {
	      isVar=false;
          if (varOrFunction.expr instanceof UnaryExpression) {
	      	var UnaryExpression u = varOrFunction.expr as UnaryExpression
	      	if (u.uop == ":") isVar=true;
	      }
	    }
	    if(isVar) {
	      switch insideWhere {
	      	case NotWhere : return compileVar(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      	case ReadingWhere : return compileVarR(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      	case WritingWhere : return compileVarW(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      }
	    }
	    else {
	      switch insideWhere {
	      	case NotWhere : return compileFunction(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      	case ReadingWhere : return compileFunction(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      	case WritingWhere : return compileFunction(indent,precedence,lhs,varOrFunction,insideWhere,parentScope)
	      }
	    }
      }

	def CharSequence compileVar(int indent,int precedence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope) 
        '''
	    «val NamespaceScope scope =parentScope.getScope(varOrFunction)»«
        cop(48,precedence)»«
	    var boolean dynamic=false»«
	    var boolean addSpace=false»«
	    var boolean global = false»«
	    var String varName = "unknown"»«
	    IF varOrFunction.expr !== null»«
	      IF (varOrFunction.expr instanceof UnaryExpression)»«
	        {addSpace=true;null}»«
	      ENDIF»«
	      {if (varOrFunction.expr instanceof UnaryExpression) dynamic= (varOrFunction.expr as UnaryExpression).loc;null}»«
	    ENDIF»«
	      {varName = cleanID(varOrFunction.name);
	      global = vars.isGlobal(varName);
	      null}»«
	      getVariable(varName,lhs)»«
	    if (addSpace) " " else ""»«
	    IF varOrFunction.expr !== null»«compile(indent,48,lhs,varOrFunction.expr,insideWhere,scope)»«ENDIF»«
	    ccp(48,precedence)»'''

	def CharSequence compileVarR(int indent,int precedence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope) 
        '''
	    «cop(48,precedence)»«
	    cleanID(varOrFunction.name)»«
	    ccp(48,precedence)»'''

	def CharSequence compileVarW(int indent,int precedence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope) 
        '''
	    «cop(48,precedence)»«
	    cleanID(varOrFunction.name)»«
	    ccp(48,precedence)»'''


	def CharSequence compileFunction(int indent,int precedence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(varOrFunction)»«
        cop(48,precedence)»«
	    var boolean addSpace=false»«
	    IF varOrFunction.expr !== null»«
	      IF (!(varOrFunction.expr instanceof Tuple))»«
	        {addSpace=true;null}»«
	      ENDIF»«
	    ENDIF»«
	    cleanID(varOrFunction.name)»«
	    if (addSpace) " " else ""»«
	    IF varOrFunction.expr !== null»«compile(indent,48,lhs,varOrFunction.expr,insideWhere,scope)»«ENDIF»«
	    IF vars.isLispFunction(cleanID(varOrFunction.name))»$Lisp«
	    ENDIF»«
	    ccp(48,precedence)»'''

    /**
     * Literal  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,Literal literal,WhereState insideWhere,RefType refType) {
        if (literal instanceof ListLiteral) return setNamespace(parent,precedence,literal as ListLiteral,insideWhere,refType);
        if (literal instanceof LispLiteral) return setNamespace(parent,precedence,literal as LispLiteral,insideWhere,refType);
        return new NullScope(null,null,null);
	}

/*
 * Literal:
 * // numeric literal
 * value=Numeric
 * // boolean literals
 * | bool='true'
 * | bool='false'
 *   // null
 * | nil='NIL'
 * | nil='nil'
 *   // other
 * | lst=ListLiteral
 * | lsp=LispLiteral
 * | str=TK_STRING
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,Literal literal,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «IF literal instanceof LispLiteral»«compile(indent,precedence,lhs,literal as LispLiteral,insideWhere,parentScope)»«ENDIF»«
	    IF literal instanceof ListLiteral»[«compile(indent,precedence,lhs,literal as ListLiteral,insideWhere,parentScope)»]«ENDIF»«
		IF literal.value !== null»«
		  literal.value»«
		  IF literal.d»..«ENDIF»«
		ENDIF»«
		IF literal.bool !== null»«literal.bool»«ENDIF»«
		IF literal.nil !== null»«literal.nil»«ENDIF»«
		IF literal.str !== null»«literal.str»«ENDIF»'''

    /**
     * LispLiteral  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,LispLiteral lispLiteral,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,lispLiteral,null);
	    parent.addSubscope(ns);
	    if (lispLiteral.sll !== null) setNamespace(ns,0,lispLiteral.sll,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*
 * LispLiteral:
  p+=KW_PRIME+ sll=SubLispLiteral
  * 
  * Don't put space before prime(s) if first in a line
  * Do put space before prime(s) if following
  */
	def CharSequence compile(int indent,int precedence,boolean lhs,LispLiteral lispLiteral,WhereState insideWhere,NamespaceScope parentScope)
        '''
        «FOR x:lispLiteral.pr»«x»«ENDFOR»«
        IF lispLiteral.sll !== null»«compile(indent,precedence,lhs,lispLiteral.sll,insideWhere,parentScope)»«ENDIF»'''

    /**
     * SubLispLiteral */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,SubLispLiteral subLispLiteral,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,subLispLiteral,cleanID(subLispLiteral.name));
	    parent.addSubscope(ns);
	    for (AnnotatedSubLispLiteral x:subLispLiteral.asl)
	        setNamespace(ns,0,x,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*
 * SubLispLiteral:
	name=TK_ID // need to accept '%a 
	|
	// allow keywords to be used in lisp literals 
    key=('not' | 'and' | 'or' | 'for' | 'while' | 'where' | 'local' | 'package' | 'exquo' |
    'true' | 'false' | 'is' | 'isnt' | 'repeat' |'until' | 'DEFPARAMETER' | 'DEFCONST' |
    'DEFCONSTANT' | 'DEFVAR' |
	'NIL' | 'nil')
	|
	m?=KW_MINUS? num=Numeric
	|
	NL? st=TK_STRING
	|
	( NL? oparen=KW_OPAREN asl+=AnnotatedSubLispLiteral* KW_CPAREN)
  */
	def CharSequence compile(int indent,int precedence,boolean lhs,SubLispLiteral subLispLiteral,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(subLispLiteral)»«
        IF subLispLiteral.name !== null»«cleanID(subLispLiteral.name)»«ENDIF»«
	    IF subLispLiteral.m»-«ENDIF»«
	    IF subLispLiteral.num !== null»«subLispLiteral.num»«ENDIF»«
	    IF subLispLiteral.st !== null»«subLispLiteral.st»«ENDIF»«
	    IF subLispLiteral.key !== null»«subLispLiteral.key»«ENDIF»«
	    var Boolean inParen = true»«var Boolean first = true»«
	    FOR x:subLispLiteral.asl»«
	      IF x.sl !== null»«
	        IF x.sl.m »«{inParen = false;null}»«ENDIF»«
	      ENDIF»«
	      {if (!first) inParen = true;null}»«
	      {first = false;null}»«
	    ENDFOR»«
	    IF subLispLiteral.oparen && inParen»(«ENDIF»«
	    FOR x:subLispLiteral.asl»«
	      compile(indent,0,lhs,x,insideWhere,scope)» «
	    ENDFOR»«
	    IF subLispLiteral.oparen && inParen»)«ENDIF»'''

    /**
     * AnnotatedSubLispLiteral */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,AnnotatedSubLispLiteral annotatedSubLispLiteral,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,annotatedSubLispLiteral,null);
	    parent.addSubscope(ns);
	    if (annotatedSubLispLiteral.sl !== null) setNamespace(ns,0,annotatedSubLispLiteral.sl,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/* AnnotatedSubLispLiteral:
 *  p?=KW_PRIME? sl=SubLispLiteral d?=KW_DOT?
 *  */
	def CharSequence compile(int indent,int precedence,boolean lhs,AnnotatedSubLispLiteral annotatedSubLispLiteral,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(annotatedSubLispLiteral)»«
        IF annotatedSubLispLiteral.p»'«ENDIF»«
	    IF annotatedSubLispLiteral.sl !== null»«compile(indent,0,lhs,annotatedSubLispLiteral.sl,insideWhere,scope)»«ENDIF»«
	    IF annotatedSubLispLiteral.d» .«ENDIF»'''

    /**
     * ListLiteral  */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ListLiteral listLiteral,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,listLiteral,null);
	    parent.addSubscope(ns);
	    for (ListElement x:listLiteral.le)
	        setNamespace(ns,0,x,insideWhere,RefType.InsideFunction);
	    for (ListComprehension x:listLiteral.sl)
	        setNamespace(ns,0,x,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*
 * ListLiteral:
// may be empty list so ob ensures literal is created
ob?= KW_OBRACK
le+=ListElement?
(KW_COMMA NL? le+=ListElement)*
sl+=ListComprehension*
KW_CBRACK
 */	    
	def CharSequence compile(int indent,int precedence,boolean lhs,ListLiteral listLiteral,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(listLiteral)»«
        var testparams=false»«
        FOR x:listLiteral.le»«if(testparams)','»«compile(indent,0,lhs,x,insideWhere,scope)»«{testparams=true;null}»«ENDFOR»«
        FOR x:listLiteral.sl»«compile(indent,0,lhs,x,insideWhere,parentScope)»«ENDFOR»'''


    /**
     * ListElement */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ListElement listElement,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,listElement,null);
	    parent.addSubscope(ns);
	    if (listElement.l2 !== null) setNamespace(ns,0,listElement.l2,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*
 * ListElement:
	(
		(c?=KW_COLON? e?=KW_EQ)? l2=IfExpression |
		c2?=KW_COLON? d?=KW_DOT
	)
 */
	def CharSequence compile(int indent,int precedence,boolean lhs,ListElement listElement,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(listElement)»«
        IF listElement.c»:«
          IF listElement.e» «ENDIF»«
        ENDIF»«
        IF listElement.e»=«ENDIF»«
        IF listElement.l2 !== null»«compile(indent,0,lhs,listElement.l2,insideWhere,scope)» «ENDIF»«
        IF listElement.c2»:«ENDIF»«
        IF listElement.d».«ENDIF»'''

    /**
     * ListComprehension */
	def NamespaceScope setNamespace(NamespaceScope parent,int precedence,ListComprehension listComprehension,WhereState insideWhere,RefType refType) {
		val NamespaceScope ns = new NamespaceScope(parent,listComprehension,null);
	    parent.addSubscope(ns);
	    //if (listComprehension.sl2 !== null) setNamespace(ns,0,listComprehension.sl2,insideWhere,RefType.InsideFunction);
	    return ns;
	}

/*
 * ListComprehension:
  (sl1=('for'|'while'|'where'|KW_BAR) sl2=Expression
  	|
  	r?='repeat'
  )
 */	    
	def CharSequence compile(int indent,int precedence,boolean lhs,ListComprehension listComprehension,WhereState insideWhere,NamespaceScope parentScope)
        '''
	    «val NamespaceScope scope =parentScope.getScope(listComprehension)»«
        IF listComprehension.sl1 !== null» «listComprehension.sl1» «ENDIF»«
	    IF listComprehension.sl2 !== null»«compile(indent,0,lhs,listComprehension.sl2,insideWhere,scope)»«ENDIF»«
	    IF listComprehension.r» repeat «ENDIF»'''
}
/* Code Generator Template Notes
 * -----------------------------
 * Template commands:
 * 
 * FOR
 * ENDFOR
 * IF
 * ELSE
 * ENDIF
 * ELSEIF
 * 
 * To display filename use:
 *      «IF function.eContainer !== null»
 *           function «function.eResource.className»;
 *      «ENDIF»
 *
 * To use Booleans:
 *
 *    «IF block.b»true«ELSE»false«ENDIF»
 */
