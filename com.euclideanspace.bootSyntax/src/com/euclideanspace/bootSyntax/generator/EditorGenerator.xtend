/*
 * generated by Xtext 2.12.0
 */
package com.euclideanspace.bootSyntax.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.euclideanspace.bootSyntax.editor.Model
import com.euclideanspace.bootSyntax.editor.Declaration
import com.euclideanspace.bootSyntax.editor.Package
import com.euclideanspace.bootSyntax.editor.Comment
import com.euclideanspace.bootSyntax.editor.Documentation
import com.euclideanspace.bootSyntax.editor.Defparameter
import com.euclideanspace.bootSyntax.editor.Defconstant
import com.euclideanspace.bootSyntax.editor.Defconst
import com.euclideanspace.bootSyntax.editor.Defvar
import com.euclideanspace.bootSyntax.editor.FunctionDef
import com.euclideanspace.bootSyntax.editor.GlobalVariable
import com.euclideanspace.bootSyntax.editor.Statement
import com.euclideanspace.bootSyntax.editor.Loop
import com.euclideanspace.bootSyntax.editor.LoopCondition
//import com.euclideanspace.bootSyntax.editor.While
import com.euclideanspace.bootSyntax.editor.Do
//import com.euclideanspace.bootSyntax.editor.Until
//import com.euclideanspace.bootSyntax.editor.For
import com.euclideanspace.bootSyntax.editor.Where
import com.euclideanspace.bootSyntax.editor.Expr
import com.euclideanspace.bootSyntax.editor.Expression
import com.euclideanspace.bootSyntax.editor.ExitExpression
import com.euclideanspace.bootSyntax.editor.OrExpression
import com.euclideanspace.bootSyntax.editor.AndExpression
import com.euclideanspace.bootSyntax.editor.EqualityExpression
import com.euclideanspace.bootSyntax.editor.RelationalExpression
import com.euclideanspace.bootSyntax.editor.IsExpression
import com.euclideanspace.bootSyntax.editor.InExpression
import com.euclideanspace.bootSyntax.editor.SegmentExpression
import com.euclideanspace.bootSyntax.editor.AdditiveExpression
import com.euclideanspace.bootSyntax.editor.ExquoExpression
import com.euclideanspace.bootSyntax.editor.DivisionExpression
import com.euclideanspace.bootSyntax.editor.QuoExpression
import com.euclideanspace.bootSyntax.editor.ModExpression
import com.euclideanspace.bootSyntax.editor.RemExpression
import com.euclideanspace.bootSyntax.editor.MultiplicativeExpression
import com.euclideanspace.bootSyntax.editor.ExponentExpression
import com.euclideanspace.bootSyntax.editor.MapExpression
import com.euclideanspace.bootSyntax.editor.AssignExpression
import com.euclideanspace.bootSyntax.editor.EltExpression
import com.euclideanspace.bootSyntax.editor.UnaryExpression
import com.euclideanspace.bootSyntax.editor.VarOrFunction
import com.euclideanspace.bootSyntax.editor.Tuple
import com.euclideanspace.bootSyntax.editor.Literal
import com.euclideanspace.bootSyntax.editor.LispLiteral
import com.euclideanspace.bootSyntax.editor.SubLispLiteral
import com.euclideanspace.bootSyntax.editor.AnnotatedSubLispLiteral
import com.euclideanspace.bootSyntax.editor.ListLiteral
import com.euclideanspace.bootSyntax.editor.ListElement
import com.euclideanspace.bootSyntax.editor.ListComprehension
import com.euclideanspace.bootSyntax.editor.WhereExpression
import com.euclideanspace.bootSyntax.editor.IfExpression
import com.euclideanspace.bootSyntax.editor.LambdaExpression
import com.euclideanspace.bootSyntax.editor.Block
import java.util.ArrayList

/* rules for indentation
 * ---------------------
 * newline(indent) inserted after every declaration
 * newline(indent) inserted after every statement in block
 * 
 * should these be before?
 */

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EditorGenerator extends AbstractGenerator {

    BootNamespace vars = new BootNamespace();
    var String currentFile ="";
    var String currentFunction ="";
    var ArrayList<Statement> pendingWheres = new ArrayList<Statement>();
    var ArrayList<LambdaExpression> pendingLambda = new ArrayList<LambdaExpression>();
    /** 'locals' is used in second (compileImplementation) pass to
     * determine if we need to add :SExpression type. This is only
     * needed for first occurrence in function.
     * see getVariable */
    var ArrayList<String> locals = new ArrayList<String>();
    

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
      fsa.generateFile(resource.className+".spad", compile(0,0,false,resource.contents.head as Model,WhereState.NotWhere))
      fsa.generateFile("namespace.txt",vars.showDefs())
   }

 	def className(Resource res) {
		var name = res.URI.lastSegment
		currentFile = name.substring(0, name.indexOf('.'))
		return currentFile;
	}

	def CharSequence newline(int indent) {
		var String s= System.lineSeparator()
		for(var int i=0; i<indent; i++) {
			s=s+"  "
		}
		return s
	}

    /*
     * cop (conditional open parenthesis)
     * This inserts open parenthesis only if it is required by
     * precidence rules.
     */
	def String cop(int innerPrecidence,int outerPrecidence) {
		if (innerPrecidence < outerPrecidence) return "(" else return ""
	}

    /*
     * ccp (conditional close parenthesis)
     * This inserts close parenthesis only if it is required by
     * precidence rules.
     */
	def String ccp(int innerPrecidence,int outerPrecidence) {
		if (innerPrecidence < outerPrecidence) return ")" else return ""
	}

    /**
     * converts long filename to format used by old Microsoft OS
     */
	def String shortName(String a) {
		var int last=4;
		var String b = a.replaceAll("-","");
		b = b.replaceAll("_","");
		if (b.length()<4) last= b.length();
		"BOOL"+b.substring(0,last).toUpperCase();
	}

    /**
     * called when a variable name is used
     */
	def String getVariable(String a,boolean lhs) {
		var boolean addType = false;
		if (lhs) {
		  if (vars.isLocal(a,currentFunction)) {
		    if (!locals.contains(a)) {
		    	addType = true;
		    	locals.add(a);
		    }
		  }
		}
		if (addType) return a + ":SExpression";
		return a;
	}

/*
 * some keywords are changed so that they are not taken as keywords
 * in our language. This changes them back to what they should be.
 */
	def String cleanID(String a) {
		if (a.equals("if1")) return "if"
		if (a.equals("and1")) return "and"
		if (a.equals("or1")) return "or"
		if (a.equals("not1")) return "not"
		if (a.equals("is1")) return "is"
		if (a.equals("package1")) return "package"
		if (a.equals("local1")) return "local"
		if (a.equals("until1")) return "until"
		return a
	}

    /**
     * Model
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,Model model,WhereState insideWhere)
	    '''
	    «var String longName = "** no resource **"»«
	    IF model.eResource !== null»«{longName = model.eResource.className;null}»«
	    ENDIF»)abbrev package «shortName(longName)» «longName»
	    «longName»() : Exports == Implementation where«
	    {setNamespace(indent+1,precidence,model,WhereState.NotWhere);null}»«
	    compileExports(indent+1,precidence,model,WhereState.NotWhere)»«
	    compileImplementation(indent+1,precidence,model,insideWhere)»'''

    /**
     * Model
     */
	def void setNamespace(int indent,int precidence,Model model,WhereState insideWhere) {
		for (Declaration x: model.declarations) {
		  setNamespace(indent+1,precidence,x,insideWhere);
		}
	}

    /**
     * Model
     */
	def CharSequence compileExports(int indent,int precidence,Model model,WhereState insideWhere)
	    '''
	    «newline(indent)»Exports ==> with«
	    FOR x:model.declarations»«compileExports(indent+1,precidence,x,insideWhere)»«ENDFOR»'''

    /**
     * Model
     */
	def CharSequence compileImplementation(int indent,int precidence,Model model,WhereState insideWhere)
	    '''
	    «newline(indent)»«
	    newline(indent)»Implementation ==> add«
	    newline(indent+1)»«
	    FOR x:model.declarations»«compile(indent+1,precidence,false,x,insideWhere)»«ENDFOR»'''

    /**
     * Declaration
     */
	def void setNamespace(int indent,int precidence,Declaration declaration,WhereState insideWhere) {
		if (declaration instanceof Defparameter)
	       setNamespace(indent,precidence,declaration as Defparameter,insideWhere)
	    if (declaration instanceof Defconstant)
	       setNamespace(indent,precidence,declaration as Defconstant,insideWhere)
	    if (declaration instanceof Defconst)
	       setNamespace(indent,precidence,declaration as Defconst,insideWhere)
	    if (declaration instanceof Defvar)
	       setNamespace(indent,precidence,declaration as Defvar,insideWhere)
	    if (declaration instanceof FunctionDef)
	       setNamespace(indent,precidence,declaration as FunctionDef,insideWhere)
	    if (declaration instanceof GlobalVariable)
	       setNamespace(indent,precidence,declaration as GlobalVariable,insideWhere)
	}

    /**
     * Declaration
     */
	def CharSequence compileExports(int indent,int precidence,Declaration declaration,WhereState insideWhere)
	    '''
	    «IF declaration instanceof FunctionDef»«
	       compileExports(indent,precidence,declaration as FunctionDef,insideWhere)»«ENDIF»'''

    /**
     * Declaration
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,Declaration declaration,WhereState insideWhere)
	    '''
	    «newline(indent)»«
	    IF declaration instanceof Package»«
	       compile(indent,precidence,lhs,declaration as Package,insideWhere)»«ENDIF»«
	    IF declaration instanceof Comment»«
	       compile(indent,precidence,lhs,declaration as Comment,insideWhere)»«ENDIF»«
	    IF declaration instanceof Documentation»«
	       compile(indent,precidence,lhs,declaration as Documentation,insideWhere)»«ENDIF»«
	    IF declaration instanceof FunctionDef»«
	       compile(indent,precidence,lhs,declaration as FunctionDef,insideWhere)»«ENDIF»«
	    IF declaration instanceof Where»«
	       compile(indent,precidence,lhs,declaration as Where,insideWhere)»«ENDIF»«
	    IF declaration instanceof GlobalVariable»«
	       compile(indent,precidence,lhs,declaration as GlobalVariable,insideWhere)»«ENDIF»'''
	
    /**
     * Package
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,Package package1,WhereState insideWhere)
	    '''«null»'''

    /**
     * Comment
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,Comment comment,WhereState insideWhere)
	    '''
	    «IF comment.c !== null»«comment.c»«ENDIF»'''

   /**
     * Documentation
     *
     *	KW_CPAREN ('if' e=Expression | ei?='endif')
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,Documentation documentation,WhereState insideWhere)
	    '''
	    «IF documentation.ei»)endif«
	    ELSEIF documentation.e !== null»)if «compile(indent,precidence,lhs,documentation.e,insideWhere)»«ENDIF»'''

    /**
     * Defparameter
     * 'DEFPARAMETER' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def void setNamespace(int indent,int precidence,Defparameter defparameter,WhereState insideWhere) {
	    vars.addDefparam(defparameter.name);
    }

    /**
     * Defconstant
     * 'DEFCONSTANT' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def void setNamespace(int indent,int precidence,Defconstant defconstant,WhereState insideWhere) {
	    vars.addDefconstant(defconstant.name);
	}

    /**
     * Defconst
     * 'DEFCONST' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def void setNamespace(int indent,int precidence,Defconst defconst,WhereState insideWhere) {
	  vars.addDefconst(defconst.name);
	}

    /**
     * Defvar
     * 'DEFVAR' KW_OPAREN name=TK_ID (KW_COMMA e=Expression)? KW_CPAREN;
     */
	def void setNamespace(int indent,int precidence,Defvar defvar,WhereState insideWhere) {
	    vars.addDefvar(defvar.name);
	}

    /**
     * FunctionDef
     */
	def void setNamespace(int indent,int precidence,FunctionDef function,WhereState insideWhere){
        var int ind = indent;
        var boolean loadCode = false;
        //vars.clearLocal();
	    if (function.name !== null) {
	      currentFunction = function.name;
	       if (function.name.equals("loadInit")) {
	      	ind = -1;loadCode=true
	       }
        }
        var ArrayList<String> params = new ArrayList<String>();
        for (Expr p:function.params) {
          if (p instanceof VarOrFunction) {
          	val VarOrFunction v = p as VarOrFunction;
          	params.add(v.name);
          }

        }
        vars.addFunction(function.name,null,currentFile,params);
	    if (function.st !== null)
	      setNamespace(ind,precidence,function.st,insideWhere)
	    if (function.w !== null)
	      setNamespace(ind,precidence,function.w,insideWhere)
	    for (Statement st:pendingWheres)
	      setNamespace(indent,precidence,st,WhereState.WritingWhere);
	    pendingWheres.clear();
	}

    /**
     * FunctionDef
     * top level function definition, inner functions use lambda */
	def CharSequence compileExports(int indent,int precidence,FunctionDef function,WhereState insideWhere)
        '''
        «var int ind = indent»«
        newline(indent)»«
	    IF function.name !== null»«
	     {currentFunction = function.name;null}»«
	    ENDIF»«
	    IF function.name !== null»«function.name»«ENDIF»«
	    FOR x:function.fp»'«ENDFOR»(BootEnvir«
	    IF function.j !== null»«function.j»«ELSE»«
	      FOR x:function.params», SExpression«ENDFOR»«
	    ENDIF»)«
	    IF function.st !== null»«
	      compileExports(ind,precidence,function.st,insideWhere)»«
	    ENDIF»«
	    IF function.w !== null»«
	      newline(ind)»«
	      compileExports(ind,precidence,function.w,insideWhere)»«
	    ENDIF»«
	    FOR Statement st:pendingWheres»«
	      compileExports(indent,precidence,st,WhereState.WritingWhere)»«
	    ENDFOR»«
	    {pendingWheres.clear();null}»'''

    /**
     * FunctionDef
     * FunctionDef definition
    Function:
    name=TK_ID fp+=KW_PRIME*
    (
      (KW_OPAREN (params+=Expression (KW_COMMA params+=Expression)*)? KW_CPAREN)
      |  j=TK_ID // support juxtapose
    )
	((KW_EQ2|m?=KW_MARROW) b=Block)? // function may be abstract
	* 
	*/
	def CharSequence compile(int indent,int precidence,boolean lhs,FunctionDef function,WhereState insideWhere)
        '''
        «var int ind = indent»«
        {locals.clear();null}»«
	    IF function.name !== null»«
	     { currentFunction = function.name;null}»«
	    ENDIF»«
	    IF function.name !== null»«function.name»«ENDIF»«
	    FOR x:function.fp»'«ENDFOR»(bootEnvir«
	    IF function.j !== null»«function.j»«ELSE»«
	      FOR x:function.params»«
	        »,«compile(indent,precidence,true,x,insideWhere)»«
	      ENDFOR»«
	    ENDIF»)«
	    IF function.st !== null»«
	      IF function.m» ==>«ELSE» ==«ENDIF»«
	      FOR String globVar: vars.getReadGlobal(currentFunction)»«
	        newline(ind+1)»«globVar»=getVar(bootEnvir,"«globVar»")«
	      ENDFOR»«
	      compile(ind,precidence,lhs,function.st,insideWhere)»«
	    ENDIF»«
	    IF function.w !== null»«
	      newline(ind)»«
	      compile(ind,precidence,lhs,function.w,insideWhere)»«
	    ENDIF»«
	    newline(ind)»«
	    FOR LambdaExpression le:pendingLambda»«
	      compile(indent,precidence,lhs,le,WhereState.WritingWhere)»«
	    ENDFOR»«
	    {pendingLambda.clear();null}»'''

   /**
    * GlobalVariable
    */
	def void setNamespace(int indent,int precidence,GlobalVariable globalVariable,WhereState insideWhere) {
      if (globalVariable.name !== null) vars.addGlobal(globalVariable.name);
    }

   /**
    * GlobalVariable
    *
    * name=TK_ID KW_ASSIGN e=Expression */
	def CharSequence compile(int indent,int precidence,boolean lhs,GlobalVariable globalVariable,WhereState insideWhere)
        '''
	    «IF globalVariable.name !== null»«globalVariable.name»«ENDIF» :=«
	    IF globalVariable.e !== null»«compile(indent,precidence,lhs,globalVariable.e,insideWhere)»«ENDIF»'''

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def void setNamespace(int indent,int precidence,Statement statement,WhereState insideWhere) {
	  if (statement instanceof Loop)
	       setNamespace(indent,precidence,statement as Loop,insideWhere);
	  if (statement instanceof Do)
	       setNamespace(indent,precidence,statement as Do,insideWhere);
      if (statement instanceof Where)
	       setNamespace(indent,precidence,statement as Where,insideWhere);
	  if (statement instanceof Expr)
	       setNamespace(indent,precidence,statement as Expr,insideWhere);
    }

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def CharSequence compileExports(int indent,int precidence,Statement statement,WhereState insideWhere)
        '''
	    «IF statement instanceof Where»«
	       compileExports(indent,precidence,statement as Where,insideWhere)»«
	    ENDIF»«
	    IF statement instanceof Expr»«
	       compileExports(indent,precidence,statement as Expr,insideWhere)»«
	    ENDIF»'''

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Statement statement,WhereState insideWhere)
        '''
	    «IF statement instanceof Comment»«
	       compile(indent,precidence,lhs,statement as Comment,insideWhere)»«ENDIF»«
	    IF statement instanceof Loop»«
	       compile(indent,precidence,lhs,statement as Loop,insideWhere)»«ENDIF»«
	    IF statement instanceof Do»«
	       compile(indent,precidence,lhs,statement as Do,insideWhere)»«ENDIF»«
	    IF statement instanceof Where»«
	       compile(indent,precidence,lhs,statement as Where,insideWhere)»«ENDIF»«
	    IF statement instanceof Expr»«
	       compile(indent,precidence,lhs,statement as Expr,insideWhere)»«ENDIF»'''

/*
 * Loop:
 * c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block
 * 
 * Put space after each condition.
 * This code uses LoopCondition, While, For and Until directly rather
 * than calling their 'compile' functions. This is because trailing spaces
 * after newline are changed by auto-indent code.
 *
 */
	def void setNamespace(int indent,int precidence,Loop loop,WhereState insideWhere) {
        for(LoopCondition x:loop.c) {
          if (x.f !== null)
            if (x.f.e !== null) setNamespace(indent,0,x.f.e,insideWhere);
          if (x.w !== null)
            if (x.w.e !== null) setNamespace(indent,0,x.w.e,insideWhere);
          if (x.u !== null)
            if (x.u.e !== null) setNamespace(indent,0,x.u.e,insideWhere);
        }
        if (loop.e !== null) setNamespace(indent,0,loop.e,insideWhere);
        if (loop.b !== null)
          setNamespace(indent,precidence,loop.b,insideWhere);
      }
/*
 * Loop:
 * c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block
 * 
 * Put space after each condition.
 * This code uses LoopCondition, While, For and Until directly rather
 * than calling their 'compile' functions. This is because trailing spaces
 * after newline are changed by auto-indent code.
 *
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Loop loop,WhereState insideWhere)
        '''
        «FOR x:loop.c»«
          IF x.f !== null»«
            »for «IF x.f.e !== null»«compile(indent,0,lhs,x.f.e,insideWhere)» «ENDIF»«
          ENDIF»«
          IF x.w !== null»«
            »while «IF x.w.e !== null»«compile(indent,0,lhs,x.w.e,insideWhere)»«
              IF x.w.n»«newline(indent)» «ELSE» «ENDIF»«
            ENDIF»«
          ENDIF»«
          IF x.u !== null»«
            »until «IF x.u.e !== null»«compile(indent,0,lhs,x.u.e,insideWhere)»«
              IF x.u.n»«newline(indent)» «ELSE» «ENDIF»«
            ENDIF»«
          ENDIF»«
        ENDFOR»«
        IF loop.e !== null»|«compile(indent,0,lhs,loop.e,insideWhere)» «ENDIF»repeat «
        IF loop.b !== null»«
          compile(indent,precidence,lhs,loop.b,insideWhere)»«
        ENDIF»'''

/*
 * Do:
 * 'do' b=Block
 */
	def void setNamespace(int indent,int precidence,Do do1,WhereState insideWhere) {
        if (do1.e !== null) setNamespace(indent,0,do1.e,insideWhere);
    }

/*
 * Do:
 * 'do' b=Block
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Do do1,WhereState insideWhere)
        '''
        do «IF do1.e !== null»«compile(indent,0,lhs,do1.e,insideWhere)»«ENDIF»'''


	def void setNamespace(int indent,int precidence,Where where,WhereState insideWhere) {
	    if ((where.b !== null)&& insideWhere != WhereState.WritingWhere) pendingWheres.add(where.b)
    }

	def CharSequence compileExports(int indent,int precidence,Where where,WhereState insideWhere) {
	    if ((where.b !== null)&& insideWhere != WhereState.WritingWhere) pendingWheres.add(where.b)
        return "";
        }
/*
 * Where:
 * 'where' b=Block
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Where where,WhereState insideWhere)
        ''' where «IF (where.b !== null) && insideWhere != WhereState.WritingWhere»«
        compile(indent,precidence,lhs,where.b,WhereState.ReadingWhere)»«
        ENDIF»'''

	def void setNamespace(int indent,int precidence,Expr expr,WhereState insideWhere) {
        if (expr instanceof WhereExpression) setNamespace(indent,precidence,expr as WhereExpression,insideWhere);
	    if (expr instanceof IfExpression) setNamespace(indent,precidence,expr as IfExpression,insideWhere);
	    if (expr instanceof Expression) setNamespace(indent,precidence,expr as Expression,insideWhere);
	    if (expr instanceof OrExpression) setNamespace(indent,precidence,expr as OrExpression,insideWhere);
	    if (expr instanceof AndExpression) setNamespace(indent,precidence,expr as AndExpression,insideWhere);
	    if (expr instanceof EqualityExpression) setNamespace(indent,precidence,expr as EqualityExpression,insideWhere);
	    if (expr instanceof RelationalExpression) setNamespace(indent,precidence,expr as RelationalExpression,insideWhere);
	    if (expr instanceof IsExpression) setNamespace(indent,precidence,expr as IsExpression,insideWhere);
	    if (expr instanceof InExpression) setNamespace(indent,precidence,expr as InExpression,insideWhere);
        if (expr instanceof SegmentExpression) setNamespace(indent,precidence,expr as SegmentExpression,insideWhere);
        if (expr instanceof AdditiveExpression) setNamespace(indent,precidence,expr as AdditiveExpression,insideWhere);
        if (expr instanceof ExquoExpression) setNamespace(indent,precidence,expr as ExquoExpression,insideWhere);
        if (expr instanceof DivisionExpression) setNamespace(indent,precidence,expr as DivisionExpression,insideWhere);
        if (expr instanceof QuoExpression) setNamespace(indent,precidence,expr as QuoExpression,insideWhere);
        if (expr instanceof ModExpression) setNamespace(indent,precidence,expr as ModExpression,insideWhere);
        if (expr instanceof RemExpression) setNamespace(indent,precidence,expr as RemExpression,insideWhere);
        if (expr instanceof MultiplicativeExpression) setNamespace(indent,precidence,expr as MultiplicativeExpression,insideWhere);
        if (expr instanceof ExponentExpression) setNamespace(indent,precidence,expr as ExponentExpression,insideWhere);
        if (expr instanceof MapExpression) setNamespace(indent,precidence,expr as MapExpression,insideWhere);
	    if (expr instanceof LambdaExpression) setNamespace(indent,precidence,expr as LambdaExpression,insideWhere);
	    if (expr instanceof AssignExpression) setNamespace(indent,precidence,expr as AssignExpression,insideWhere);
	    if (expr instanceof ExitExpression) setNamespace(indent,precidence,expr as ExitExpression,insideWhere);
        if (expr instanceof EltExpression) setNamespace(indent,precidence,expr as EltExpression,insideWhere);
        if (expr instanceof UnaryExpression) setNamespace(indent,precidence,expr as UnaryExpression,insideWhere);
	    if (expr instanceof VarOrFunction) setNamespace(indent,precidence,expr as VarOrFunction,insideWhere);
//        if (expr instanceof Tuple) setNamespace(indent,precidence,expr as Tuple,insideWhere);
	    if (expr instanceof Block) setNamespace(indent,precidence,expr as Block,insideWhere);
//        if (expr instanceof Literal) setNamespace(indent,precidence,expr as Literal,insideWhere);
        if (expr.b1 !== null) setNamespace(indent,precidence,expr.b1,insideWhere);
        if (expr.b2 !== null) setNamespace(indent,precidence,expr.b2,insideWhere);
        if (expr.b2i !== null) setNamespace(indent,precidence,expr.b2i,insideWhere);
        if (expr.b3 !== null) setNamespace(indent,precidence,expr.b3,insideWhere);
    }

	def CharSequence compileExports(int indent,int precidence,Expr expr,WhereState insideWhere)
        '''
	    «IF expr instanceof WhereExpression»«compileExports(indent,precidence,expr as WhereExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof VarOrFunction»«compileExports(indent,precidence,expr as VarOrFunction,insideWhere)»«ENDIF»«
	    IF expr instanceof AssignExpression»«compileExports(indent,precidence,expr as AssignExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof LambdaExpression»«compileExports(indent,precidence,expr as LambdaExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof ExitExpression»«compileExports(indent,precidence,expr as ExitExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof Block»«compileExports(indent,precidence,expr as Block,insideWhere)»«ENDIF»'''

/* Expr holds both Expression and WhereExpression
 * 
 * WhereExpression returns Expr:
	(Expression ({WhereExpression.left=current} w=Where)?)
	|
	c?=KW_OCURLY (st+=Statement NL)*  KW_CCURLY (KW_EXIT eexp=Expression)?
	|
	(
	    'if' b1=InnerBlock
	    (
          =>('then' b2i=InnerBlock 'else' b3=Block) |
          ('then' b2=Block)
        )	
	)
 * 
 * the eexp is for i-syscmd in function dewritify
 *
	
PrimaryExpression returns Expr:
  (
	Literal
	| p?=KW_OPAREN m?=KW_MINUS? (t4=WhereExpression (KW_COMMA t5+=WhereExpression)*)?
    (
	b?=BEGIN
		(s+=Statement NL)*
	END NL
	)? KW_CPAREN
	|
	c2?=KW_OCURLY BEGIN (s+=Statement NL)* END NL KW_CCURLY
  )
  d=KW_2DOT? // for segment with no end part
  * 
  * from PrimaryExpression - no indent:
  * t4 is WhereExpression inside parenthesis
  * t5 is WhereExpressions inside parenthesis after comma
  * from PrimaryExpression - indent:
  * b=true
  */
	def CharSequence compile(int indent,int precidence,boolean lhs,Expr expr,WhereState insideWhere)
        '''
	    «IF expr instanceof WhereExpression»«compile(indent,precidence,lhs,expr as WhereExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof IfExpression»«compile(indent,precidence,lhs,expr as IfExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof Expression»«compile(indent,precidence,lhs,expr as Expression,insideWhere)»«ENDIF»«
	    IF expr instanceof OrExpression»«compile(indent,precidence,lhs,expr as OrExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof AndExpression»«compile(indent,precidence,lhs,expr as AndExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof EqualityExpression»«compile(indent,precidence,lhs,expr as EqualityExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof RelationalExpression»«compile(indent,precidence,lhs,expr as RelationalExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof IsExpression»«compile(indent,precidence,lhs,expr as IsExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof InExpression»«compile(indent,precidence,lhs,expr as InExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof SegmentExpression»«compile(indent,precidence,lhs,expr as SegmentExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof AdditiveExpression»«compile(indent,precidence,lhs,expr as AdditiveExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof ExquoExpression»«compile(indent,precidence,lhs,expr as ExquoExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof DivisionExpression»«compile(indent,precidence,lhs,expr as DivisionExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof QuoExpression»«compile(indent,precidence,lhs,expr as QuoExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof ModExpression»«compile(indent,precidence,lhs,expr as ModExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof RemExpression»«compile(indent,precidence,lhs,expr as RemExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof MultiplicativeExpression»«compile(indent,precidence,lhs,expr as MultiplicativeExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof ExponentExpression»«compile(indent,precidence,lhs,expr as ExponentExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof MapExpression»«compile(indent,precidence,lhs,expr as MapExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof LambdaExpression»«compile(indent,precidence,lhs,expr as LambdaExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof AssignExpression»«compile(indent,precidence,lhs,expr as AssignExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof ExitExpression»«compile(indent,precidence,lhs,expr as ExitExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof EltExpression»«compile(indent,precidence,lhs,expr as EltExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof UnaryExpression»«compile(indent,precidence,lhs,expr as UnaryExpression,insideWhere)»«ENDIF»«
	    IF expr instanceof VarOrFunction»«compile(indent,precidence,lhs,expr as VarOrFunction,insideWhere)»«ENDIF»«
	    IF expr instanceof Tuple»«compile(indent,precidence,lhs,expr as Tuple,insideWhere)»«ENDIF»«
	    IF expr instanceof Block»«compile(indent,precidence,lhs,expr as Block,insideWhere)»«ENDIF»«
	    IF expr instanceof Literal»«compile(indent,precidence,lhs,expr as Literal,insideWhere)»«ENDIF»«
	    IF expr.b1 !== null»if «
	      compile(indent,precidence,lhs,expr.b1,insideWhere)»«
	      IF expr.n1»«newline(indent)»«ELSE» «ENDIF»«
	    ENDIF»«
	    IF expr.b2 !== null»then «
	      compile(indent,precidence,lhs,expr.b2,insideWhere)» «
	    ENDIF»«
	    IF expr.b2i !== null»then «
	      compile(indent,precidence,lhs,expr.b2i,insideWhere)»«
	      IF expr.n2»«newline(indent)»«ELSE» «ENDIF»«
	    ENDIF»«
	    IF expr.b3 !== null»else «
	      compile(indent,precidence,lhs,expr.b3,insideWhere)»«ENDIF»'''

	def void setNamespace(int indent,int precidence,WhereExpression whereExpression,WhereState insideWhere) {
      if (whereExpression.left !== null) setNamespace(indent,1,whereExpression.left,insideWhere);
	  if (whereExpression.w !== null) setNamespace(indent,1,whereExpression.w,insideWhere);
    }

	def CharSequence compileExports(int indent,int precidence,WhereExpression whereExpression,WhereState insideWhere)
        '''
	    «IF whereExpression.left !== null»«compileExports(indent,1,whereExpression.left,insideWhere)»«ENDIF»«
	    IF whereExpression.w !== null» «compileExports(indent,1,whereExpression.w,insideWhere)» «ENDIF»'''

/* WhereExpression returns Expr:
	(Expression ({WhereExpression.left=current} w=Where?))
	|
	c?=KW_OCURLY (st+=Statement NL)* KW_CCURLY
	|
	(
	    'if' b1=InnerBlock
	    (
          =>('then' b2i=InnerBlock 'else' b3=Block) |
          ('then' b2=Block)
        )	
	)
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,WhereExpression whereExpression,WhereState insideWhere)
        '''
	    «IF whereExpression.left !== null»«compile(indent,1,lhs,whereExpression.left,insideWhere)»«ENDIF»«
	    IF whereExpression.w !== null» «compile(indent,1,lhs,whereExpression.w,insideWhere)» «ENDIF»'''

    /**
     * IfExpression 
     * IfExpression returns Expr:
     * Expression
     * |
     * ({IfExpression} KW_AT 'if' i1=Expression 'then' i2=Statement NL? ('else' i3=Statement NL?)? KW_AT)
     */
	def void setNamespace(int indent,int precidence,IfExpression ifExpression,WhereState insideWhere) {
      if(ifExpression.i1 !== null) setNamespace(indent,0,ifExpression.i1,insideWhere);
      if(ifExpression.i2 !== null) setNamespace(indent,0,ifExpression.i2,insideWhere);
      if(ifExpression.i3 !== null) setNamespace(indent,0,ifExpression.i3,insideWhere);
    }

    /**
     * IfExpression 
     * IfExpression returns Expr:
     * Expression
     * |
     * ({IfExpression} KW_AT 'if' i1=Expression 'then' i2=Statement NL? ('else' i3=Statement NL?)? KW_AT)
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,IfExpression ifExpression,WhereState insideWhere)
        '''
        «IF ifExpression.i1 !== null»if «compile(indent,0,lhs,ifExpression.i1,insideWhere)» «ENDIF»«
        IF ifExpression.i2 !== null»then «compile(indent,0,lhs,ifExpression.i2,insideWhere)» «ENDIF»«
        IF ifExpression.i3 !== null»«
          newline(indent)»else «
          compile(indent,0,lhs,ifExpression.i3,insideWhere)» «
        ENDIF»'''

/* Expression
 * This is top of expression tree except for WhereExpression
 * combines statements using semicolon
 */
	def void setNamespace(int indent,int precidence,Expression expression,WhereState insideWhere) {
	  if(expression.left !== null) setNamespace(indent,8,expression.left,insideWhere);
	  if(expression.right !== null) setNamespace(indent,8,expression.right,insideWhere);
	  if(expression.right2 !== null) setNamespace(indent,8,expression.right2,insideWhere);
	}

/* Expression
 * This is top of expression tree except for WhereExpression
 * combines statements using semicolon
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Expression expression,WhereState insideWhere)
        '''
	    «cop(8,precidence)»«
	    IF expression.left !== null»«compile(indent,8,lhs,expression.left,insideWhere)»«ENDIF»«
	    IF expression.op !== null» «expression.op» «ENDIF»«
	    IF expression.right !== null»«compile(indent,8,lhs,expression.right,insideWhere)»«ENDIF»«
	    IF expression.right2 !== null»«compile(indent,8,lhs,expression.right2,insideWhere)»«ENDIF»«
	    ccp(8,precidence)»'''

	def CharSequence compile(int indent,int precidence,boolean lhs,MapExpression mapExpression,WhereState insideWhere)
        '''
	    «cop(10,precidence)»«
	    IF mapExpression.left !== null»«compile(indent,10,lhs,mapExpression.left,insideWhere)»«ENDIF»«
	    IF mapExpression.op !== null» «mapExpression.op» «ENDIF»«
	    IF mapExpression.right !== null»«compile(indent,10,lhs,mapExpression.right,insideWhere)»«ENDIF»«
	    ccp(10,precidence)»'''

	def void setNamespace(int indent,int precidence,LambdaExpression lambdaExpression,WhereState insideWhere) {
        var VarOrFunction v =null;
        var fnName="";
        if (lambdaExpression.left !== null) {
          if (lambdaExpression.left instanceof VarOrFunction) {
            v=lambdaExpression.left as VarOrFunction
            	fnName=v.name
            	while (!vars.addFunction(fnName,currentFunction,currentFile,null)) fnName=fnName+"2";
          }
        }
    }

	def CharSequence compileExports(int indent,int precidence,LambdaExpression lambdaExpression,WhereState insideWhere)
        '''
        «var VarOrFunction v =null»«
        var fnName=""»«
        IF lambdaExpression.left !== null»«
          IF lambdaExpression.left instanceof VarOrFunction»«
            {v=lambdaExpression.left as VarOrFunction
            	//fnName=v.name
            	//while (!vars.addFunction(fnName,currentFunction,currentFile,null)) fnName=fnName+"2";
            	null;
            }»«
            newline(indent-1)»«
            currentFunction»«
            fnName»«
            IF v.expr !== null»«
              IF v.expr instanceof Tuple»«
                compile(indent,10,false,(v.expr as Tuple),insideWhere)»«
              ENDIF»«
            ENDIF»«
          ENDIF»«
        ENDIF»'''

	def CharSequence compile(int indent,int precidence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere) {
	  switch insideWhere {
	  	case NotWhere : return compileNotInside(indent,precidence,lhs,lambdaExpression,insideWhere)
	  	case ReadingWhere : return compileRead(indent,precidence,lhs,lambdaExpression,insideWhere)
	  	case WritingWhere : return compileWrite(indent,precidence,lhs,lambdaExpression,insideWhere)
	  }
	  return "";
    }
    
	def CharSequence compileNotInside(int indent,int precidence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere)
        '''
	    «cop(12,precidence)»«
	    IF lambdaExpression.left !== null»«compile(indent,12,lhs,lambdaExpression.left,insideWhere)»«ENDIF»«
	    IF lambdaExpression.op !== null» +-> «ENDIF»«
	    IF lambdaExpression.right !== null»«compile(indent,12,lhs,lambdaExpression.right,insideWhere)»«ENDIF»«
	    ccp(12,precidence)»'''

	def CharSequence compileRead(int indent,int precidence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere) {
		pendingLambda.add(lambdaExpression);
		return "";
	}

	def CharSequence compileWrite(int indent,int precidence,boolean lhs,LambdaExpression lambdaExpression,WhereState insideWhere)
		'''
		«newline(indent)»«
	    IF lambdaExpression.left !== null»«currentFunction»«compile(indent,12,lhs,lambdaExpression.left,insideWhere)»«ENDIF»«
	    IF lambdaExpression.op !== null» == «ENDIF»«
	    IF lambdaExpression.right !== null»«compile(indent,12,lhs,lambdaExpression.right,insideWhere)»«ENDIF»«
		newline(indent)»'''

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def void setNamespace(int indent,int precidence,ExitExpression exitExpression,WhereState insideWhere) {
        if (exitExpression.left !== null) setNamespace(indent,14,exitExpression.left,insideWhere);
	    if (exitExpression.right !== null) setNamespace(indent,14,exitExpression.right,insideWhere);
    }

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def CharSequence compileExports(int indent,int precidence,ExitExpression exitExpression,WhereState insideWhere)
        '''
        «IF exitExpression.left !== null»«compileExports(indent,14,exitExpression.left,insideWhere)»«ENDIF»«
	    IF exitExpression.right !== null»«compileExports(indent,14,exitExpression.right,insideWhere)»«ENDIF»'''

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,ExitExpression exitExpression,WhereState insideWhere)
        '''
        «cop(14,precidence)»«
	    IF exitExpression.left !== null»«compile(indent,14,lhs,exitExpression.left,insideWhere)»«ENDIF»«
	    IF exitExpression.op !== null» «exitExpression.op» «ENDIF»«
	    IF exitExpression.right !== null»«compile(indent,14,lhs,exitExpression.right,insideWhere)»«ENDIF»«
	    ccp(14,precidence)»'''

    /**
     * AssignExpression */
	def void setNamespace(int indent,int precidence,AssignExpression assignExpression,WhereState insideWhere) {
      if (assignExpression.left !== null) {
          if (assignExpression.left instanceof VarOrFunction) {
          	val VarOrFunction v = assignExpression.left as VarOrFunction;
          	vars.addWrite(v.name,currentFunction);
          }
	      setNamespace(indent,16,assignExpression.left,insideWhere);
	  }
	  if (assignExpression.right !== null) {
	      setNamespace(indent,16,assignExpression.right,insideWhere);
	  }
	}

    /**
     * AssignExpression */
	def CharSequence compileExports(int indent,int precidence,AssignExpression assignExpression,WhereState insideWhere)
        '''
	    «IF assignExpression.left !== null»«
	      compileExports(indent,16,assignExpression.left,insideWhere)»«
	    ENDIF»«
	    IF assignExpression.right !== null»«
	      compileExports(indent,16,assignExpression.right,insideWhere)»«
	    ENDIF»'''

    /**
     * AssignExpression */
	def CharSequence compile(int indent,int precidence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere) {
	    if (insideWhere!=WhereState.NotWhere) {return 
          '''
          «IF assignExpression.left !== null»«compile(indent,16,lhs,assignExpression.left,insideWhere)» := «ENDIF»«
          IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere)»«ENDIF»'''
        }
	    if (assignExpression.left !== null) {
	      if (assignExpression.left instanceof VarOrFunction)
	        return compileAssignSingle(indent,precidence,lhs,assignExpression,insideWhere);
	      if (assignExpression.left instanceof ListLiteral)
	        return compileAssignList(indent,precidence,lhs,assignExpression,insideWhere);
	    }
	    return " error cannot assign this"
    }

    /**
     * AssignExpression 
     * where left is a single variable */
	def CharSequence compileAssignSingle(int indent,int precidence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere) '''
	    «cop(16,precidence)»«
	    var String nam="unknown"»«
	    var boolean dynamic=false»«
	    var VarOrFunction v»«
        {v = (assignExpression.left as VarOrFunction);
	    nam = v.name;
	    if (v.expr instanceof UnaryExpression) dynamic= (v.expr as UnaryExpression).loc;
	    null}»«
	    IF vars.isGlobalsWritten(nam,currentFunction)»putVar(bootEnvir,"«nam»",«
	      compile(indent,16,lhs,assignExpression.left,insideWhere)» := «
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere)»«ENDIF»)«
        ELSE»«
	      compile(indent,16,true,assignExpression.left,insideWhere)»«
	      IF assignExpression.op !== null» «assignExpression.op» «ENDIF»«
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere)»«ENDIF»«
        ENDIF»«
	    cop(16,precidence)»'''

    /**
     * AssignExpression
     * where left is a list containing variables */
	def CharSequence compileAssignList(int indent,int precidence,boolean lhs,AssignExpression assignExpression,WhereState insideWhere)
        '''
	    «cop(16,precidence)»«
	    var String nam="unknown"»«
	    var ListLiteral ll»«
	    »--> assign variables inside list <---«
	    {ll = (assignExpression.left as ListLiteral);null}»«
	    IF vars.isGlobalsWritten(nam,currentFunction)»putVar(bootEnvir,"«nam»",«
	      compile(indent,16,lhs,assignExpression.left,insideWhere)» := «
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere)»«ENDIF»)«
        ELSE»«
	      compile(indent,16,true,assignExpression.left,insideWhere)»«
	      IF assignExpression.op !== null» «assignExpression.op» «ENDIF»«
	      IF assignExpression.right !== null»«compile(indent,16,lhs,assignExpression.right,insideWhere)»«ENDIF»«
        ENDIF»«
	    cop(16,precidence)»'''

    /**
     * OrExpression */
	def void setNamespace(int indent,int precidence,OrExpression orExpression,WhereState insideWhere) {
	  if(orExpression.left !== null) setNamespace(indent,18,orExpression.left,insideWhere);
	  if(orExpression.right !== null) setNamespace(indent,18,orExpression.right,insideWhere);
	}

    /**
     * OrExpression */
	def CharSequence compile(int indent,int precidence,boolean lhs,OrExpression orExpression,WhereState insideWhere)
        '''
	    «cop(18,precidence)»«
	    IF orExpression.left !== null»«compile(indent,18,lhs,orExpression.left,insideWhere)»«ENDIF»«
	    IF orExpression.op !== null» «orExpression.op» «ENDIF»«
	    IF orExpression.right !== null»«compile(indent,18,lhs,orExpression.right,insideWhere)»«ENDIF»«
	    ccp(18,precidence)»'''

    /**
     * AndExpression */
	def void setNamespace(int indent,int precidence,AndExpression andExpression,WhereState insideWhere) {
	  if(andExpression.left !== null) setNamespace(indent,20,andExpression.left,insideWhere);
	  if(andExpression.right !== null) setNamespace(indent,20,andExpression.right,insideWhere);
	}

    /**
     * AndExpression */
	def CharSequence compile(int indent,int precidence,boolean lhs,AndExpression andExpression,WhereState insideWhere)
        '''
	    «cop(20,precidence)»«
	    IF andExpression.left !== null»«compile(indent,20,lhs,andExpression.left,insideWhere)»«ENDIF»«
	    IF andExpression.op !== null» «andExpression.op» «ENDIF»«
	    IF andExpression.right !== null»«compile(indent,20,lhs,andExpression.right,insideWhere)»«ENDIF»«
	    ccp(20,precidence)»'''

    /**
     * EqualityExpression */
	def void setNamespace(int indent,int precidence,EqualityExpression equalityExpression,WhereState insideWhere) {
	  if(equalityExpression.left !== null) setNamespace(indent,20,equalityExpression.left,insideWhere);
	  if(equalityExpression.right !== null) setNamespace(indent,20,equalityExpression.right,insideWhere);
	}

 	def CharSequence compile(int indent,int precidence,boolean lhs,EqualityExpression equalityExpression,WhereState insideWhere)
        '''
	    «cop(22,precidence)»«
	    IF equalityExpression.left !== null»«compile(indent,22,lhs,equalityExpression.left,insideWhere)»«ENDIF»«
	    IF equalityExpression.op !== null» «equalityExpression.op» «ENDIF»«
	    IF equalityExpression.right !== null»«compile(indent,22,lhs,equalityExpression.right,insideWhere)»«ENDIF»«
	    ccp(22,precidence)»'''

    /**
     * RelationalExpression */
	def void setNamespace(int indent,int precidence,RelationalExpression relationalExpression,WhereState insideWhere) {
	  if(relationalExpression.left !== null) setNamespace(indent,20,relationalExpression.left,insideWhere);
	  if(relationalExpression.right !== null) setNamespace(indent,20,relationalExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,RelationalExpression relationalExpression,WhereState insideWhere)
        '''
	    «cop(24,precidence)»«
	    IF relationalExpression.left !== null»«compile(indent,24,lhs,relationalExpression.left,insideWhere)»«ENDIF»«
	    IF relationalExpression.op !== null» «relationalExpression.op» «ENDIF»«
	    IF relationalExpression.right !== null»«compile(indent,24,lhs,relationalExpression.right,insideWhere)»«ENDIF»«
	    ccp(24,precidence)»'''

    /**
     * IsExpression */
	def void setNamespace(int indent,int precidence,IsExpression isExpression,WhereState insideWhere){
	  if(isExpression.left !== null)
	      setNamespace(indent,26,isExpression.left,insideWhere);
	  if(isExpression.right !== null)
	      setNamespace(indent,26,isExpression.right,insideWhere);
	}

    /**
     * IsExpression */
	def CharSequence compile(int indent,int precidence,boolean lhs,IsExpression isExpression,WhereState insideWhere)
        '''
	    «cop(26,precidence)»«
	    IF isExpression.left !== null»«
	      compile(indent,26,lhs,isExpression.left,insideWhere)»«ENDIF»«
	    IF isExpression.op !== null» «isExpression.op» «ENDIF»«
	    IF isExpression.right !== null»«
	      compile(indent,26,true,isExpression.right,insideWhere)»«
	    ENDIF»«
	    ccp(26,precidence)»'''

    /**
     * InExpression
     */
	def void setNamespace(int indent,int precidence,InExpression inExpression,WhereState insideWhere) {
	    if(inExpression.left !== null)
          if (inExpression.left instanceof VarOrFunction) {
          	val VarOrFunction v = inExpression.left as VarOrFunction;
          	vars.addWrite(v.name,currentFunction);
          }
	      setNamespace(indent,28,inExpression.left,insideWhere);
	    if(inExpression.right !== null) setNamespace(indent,28,inExpression.right,insideWhere);
	    if(inExpression.r2 !== null) setNamespace(indent,29,inExpression.r2,insideWhere);
	}

    /**
     * InExpression
     */
	def CharSequence compile(int indent,int precidence,boolean lhs,InExpression inExpression,WhereState insideWhere)
        '''
	    «cop(28,precidence)»«
	    IF inExpression.left !== null»«
	      compile(indent,28,true,inExpression.left,insideWhere)»«
	    ENDIF»«
	    IF inExpression.op !== null» «inExpression.op» «ENDIF»«
	    IF inExpression.right !== null»«compile(indent,28,lhs,inExpression.right,insideWhere)»«ENDIF»«
	    IF inExpression.r2 !== null» by «compile(indent,29,lhs,inExpression.r2,insideWhere)»«ENDIF»«
	    ccp(28,precidence)»'''
	
    /**
     * SegmentExpression */
	def void setNamespace(int indent,int precidence,SegmentExpression segmentExpression,WhereState insideWhere){
	  if(segmentExpression.left !== null)
	      setNamespace(indent,30,segmentExpression.left,insideWhere);
	  if(segmentExpression.right !== null)
	      setNamespace(indent,30,segmentExpression.right,insideWhere);
	}

	/*
	 * ..
	 * don't put spaces around segment */ 
	def CharSequence compile(int indent,int precidence,boolean lhs,SegmentExpression segmentExpression,WhereState insideWhere)
        '''
	    «cop(30,precidence)»«
	    IF segmentExpression.left !== null»«compile(indent,30,lhs,segmentExpression.left,insideWhere)»«ENDIF»«
	    IF segmentExpression.op !== null»«segmentExpression.op»«ENDIF»«
	    IF segmentExpression.right !== null»«compile(indent,30,lhs,segmentExpression.right,insideWhere)»«ENDIF»«
	    ccp(30,precidence)»'''

    /**
     * AdditiveExpression */
	def void setNamespace(int indent,int precidence,AdditiveExpression additiveExpression,WhereState insideWhere){
	  if(additiveExpression.left !== null)
	      setNamespace(indent,32,additiveExpression.left,insideWhere);
	  if(additiveExpression.right !== null)
	      setNamespace(indent,32,additiveExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,AdditiveExpression additiveExpression,WhereState insideWhere)
        '''
	    «cop(32,precidence)»«
	    IF additiveExpression.left !== null»«compile(indent,32,lhs,additiveExpression.left,insideWhere)»«ENDIF»«
	    IF additiveExpression.op !== null» «additiveExpression.op» «ENDIF»«
	    IF additiveExpression.right !== null»«compile(indent,32,lhs,additiveExpression.right,insideWhere)»«ENDIF»«
	    ccp(32,precidence)»'''

    /**
     * ExquoExpression */
	def void setNamespace(int indent,int precidence,ExquoExpression exquoExpression,WhereState insideWhere){
	  if(exquoExpression.left !== null)
	      setNamespace(indent,34,exquoExpression.left,insideWhere);
	  if(exquoExpression.right !== null)
	      setNamespace(indent,34,exquoExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,ExquoExpression exquoExpression,WhereState insideWhere)
        '''
	    «cop(34,precidence)»«
	    IF exquoExpression.left !== null»«compile(indent,34,lhs,exquoExpression.left,insideWhere)»«ENDIF»«
	    IF exquoExpression.op !== null» «exquoExpression.op» «ENDIF»«
	    IF exquoExpression.right !== null»«compile(indent,34,lhs,exquoExpression.right,insideWhere)»«ENDIF»«
	    ccp(34,precidence)»'''

    /**
     * DivisionExpression */
	def void setNamespace(int indent,int precidence,DivisionExpression divisionExpression,WhereState insideWhere){
	  if(divisionExpression.left !== null)
	      setNamespace(indent,36,divisionExpression.left,insideWhere);
	  if(divisionExpression.right !== null)
	      setNamespace(indent,36,divisionExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,DivisionExpression divisionExpression,WhereState insideWhere)
        '''
	    «cop(36,precidence)»«
	    IF divisionExpression.left !== null»«compile(indent,36,lhs,divisionExpression.left,insideWhere)»«ENDIF»«
	    IF divisionExpression.op !== null» «divisionExpression.op» «ENDIF»«
	    IF divisionExpression.right !== null»«compile(indent,36,lhs,divisionExpression.right,insideWhere)»«ENDIF»«
	    ccp(363,precidence)»'''

    /**
     * QuoExpression */
	def void setNamespace(int indent,int precidence,QuoExpression quoExpression,WhereState insideWhere){
	  if(quoExpression.left !== null)
	      setNamespace(indent,16,quoExpression.left,insideWhere);
	  if(quoExpression.right !== null)
	      setNamespace(indent,16,quoExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,QuoExpression quoExpression,WhereState insideWhere)
        '''
	    «cop(16,precidence)»«
	    IF quoExpression.left !== null»«compile(indent,16,lhs,quoExpression.left,insideWhere)»«ENDIF»«
	    IF quoExpression.op !== null» «quoExpression.op» «ENDIF»«
	    IF quoExpression.right !== null»«compile(indent,16,lhs,quoExpression.right,insideWhere)»«ENDIF»«
	    ccp(16,precidence)»'''

    /**
     * ModExpression */
	def void setNamespace(int indent,int precidence,ModExpression modExpression,WhereState insideWhere){
	  if(modExpression.left !== null)
	      setNamespace(indent,38,modExpression.left,insideWhere);
	  if(modExpression.right !== null)
	      setNamespace(indent,38,modExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,ModExpression modExpression,WhereState insideWhere)
        '''
	    «cop(38,precidence)»«
	    IF modExpression.left !== null»«compile(indent,38,lhs,modExpression.left,insideWhere)»«ENDIF»«
	    IF modExpression.op !== null» «modExpression.op» «ENDIF»«
	    IF modExpression.right !== null»«compile(indent,38,lhs,modExpression.right,insideWhere)»«ENDIF»«
	    ccp(38,precidence)»'''

    /**
     * RemExpression */
	def void setNamespace(int indent,int precidence,RemExpression remExpression,WhereState insideWhere){
	  if(remExpression.left !== null)
	      setNamespace(indent,40,remExpression.left,insideWhere);
	  if(remExpression.right !== null)
	      setNamespace(indent,40,remExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,RemExpression remExpression,WhereState insideWhere)
        '''
	    «cop(40,precidence)»«
	    IF remExpression.left !== null»«compile(indent,40,lhs,remExpression.left,insideWhere)»«ENDIF»«
	    IF remExpression.op !== null» «remExpression.op» «ENDIF»«
	    IF remExpression.right !== null»«compile(indent,40,lhs,remExpression.right,insideWhere)»«ENDIF»«
	    ccp(40,precidence)»'''

    /**
     * MultiplicativeExpression */
	def void setNamespace(int indent,int precidence,MultiplicativeExpression multiplicativeExpression,WhereState insideWhere){
	  if(multiplicativeExpression.left !== null)
	      setNamespace(indent,42,multiplicativeExpression.left,insideWhere);
	  if(multiplicativeExpression.right !== null)
	      setNamespace(indent,42,multiplicativeExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,MultiplicativeExpression multiplicativeExpression,WhereState insideWhere)
        '''
	    «cop(42,precidence)»«
	    IF multiplicativeExpression.left !== null»«compile(indent,42,lhs,multiplicativeExpression.left,insideWhere)»«ENDIF»«
	    IF multiplicativeExpression.op !== null» «multiplicativeExpression.op»«ENDIF»«
	    IF multiplicativeExpression.right !== null»«compile(indent,42,lhs,multiplicativeExpression.right,insideWhere)»«ENDIF»«
	    ccp(42,precidence)»'''

    /**
     * ExponentExpression  */
	def void setNamespace(int indent,int precidence,ExponentExpression exponentExpression,WhereState insideWhere){
	  if(exponentExpression.left !== null)
	      setNamespace(indent,44,exponentExpression.left,insideWhere);
	  if(exponentExpression.right !== null)
	      setNamespace(indent,44,exponentExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,ExponentExpression exponentExpression,WhereState insideWhere)
        '''
	    «cop(44,precidence)»«
	    IF exponentExpression.left !== null»«compile(indent,44,lhs,exponentExpression.left,insideWhere)»«ENDIF»«
	    IF exponentExpression.op !== null»«exponentExpression.op» «ENDIF»«
	    IF exponentExpression.right !== null»«compile(indent,44,lhs,exponentExpression.right,insideWhere)»«ENDIF»«
	    ccp(44,precidence)»'''

    /**
     * EltExpression  */
	def void setNamespace(int indent,int precidence,EltExpression eltExpression,WhereState insideWhere){
	  if(eltExpression.left !== null)
	      setNamespace(indent,46,eltExpression.left,insideWhere);
	  if(eltExpression.right !== null)
	      setNamespace(indent,46,eltExpression.right,insideWhere);
	}

	def CharSequence compile(int indent,int precidence,boolean lhs,EltExpression eltExpression,WhereState insideWhere)
        '''
	    «cop(46,precidence)»«
	    IF eltExpression.left !== null»«compile(indent,46,lhs,eltExpression.left,insideWhere)»«ENDIF»«
	    IF eltExpression.op !== null»«eltExpression.op»«ENDIF»«
	    IF eltExpression.right !== null»«compile(indent,46,lhs,eltExpression.right,insideWhere)»«ENDIF»«
	    ccp(46,precidence)»'''

	def void setNamespace(int indent,int precidence,UnaryExpression unaryExpression,WhereState insideWhere) {
	  if (unaryExpression.b1 !== null) setNamespace(indent,48,unaryExpression.b1,insideWhere);
	  if (unaryExpression.b3 !== null) setNamespace(indent,48,unaryExpression.b3,insideWhere);
	  if (unaryExpression.expr !== null) setNamespace(indent,48,unaryExpression.expr,insideWhere);
	}

/*
 * UnaryExpression returns Expr:
PrimaryExpression |
({UnaryExpression} name=TK_ID =>p2?=KW_PRIME? expr=UnaryExpression?) |
({UnaryExpression} uop='not' expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON expr=UnaryExpression) |
({UnaryExpression} uop='or/' expr=UnaryExpression) |
({UnaryExpression} uop='and/' expr=UnaryExpression) |
({UnaryExpression} uop='+/' expr=UnaryExpression) |
({UnaryExpression} uop='*./' expr=UnaryExpression) | // needs . otherwise causes errors in xtext files
({UnaryExpression} uop='return' expr=UnaryExpression) |
({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON loc?='local')
* 
* Put a space between ID and expr but not $ and expr
* 
*/
	def CharSequence compile(int indent,int precidence,boolean lhs,UnaryExpression unaryExpression,WhereState insideWhere)
        '''
	    «cop(48,precidence)»«
	    IF unaryExpression.b1 !== null»«compile(indent,48,lhs,unaryExpression.b1,insideWhere)»«ENDIF»«
	    IF unaryExpression.b2 !== null»«unaryExpression.b2»«ENDIF»«
	    IF unaryExpression.b3 !== null»«compile(indent,48,lhs,unaryExpression.b3,insideWhere)»«ENDIF»«
	    IF unaryExpression.uop !== null»«
	      if (unaryExpression.uop.compareTo("*./")==0) "*/" else
            if (unaryExpression.uop.compareTo(":")==0) "" else
	          unaryExpression.uop»«
	      if (unaryExpression.uop.compareTo("not")==0) " "»«
	      if (unaryExpression.uop.compareTo("return")==0) " "»«
	    ENDIF»«
	    IF unaryExpression.expr !== null»«compile(indent,48,lhs,unaryExpression.expr,insideWhere)»«ENDIF»«
	    ccp(48,precidence)»'''


/*{Tuple} p?=KW_OPAREN m2?=KW_MINUS? (t3=WhereExpression NL? (KW_COMMA t5+=WhereExpression)*)? */
	def CharSequence compile(int indent,int precidence,boolean lhs,Tuple expr,WhereState insideWhere)
        '''
	    «var Boolean removeBrackets =false»«
 	    IF expr.m2»«
	      IF expr.t3 !== null»«
	        IF expr.t3 instanceof Literal»«{removeBrackets =true;null}»«ENDIF»«
	      ENDIF»«
	    ENDIF»«
	    IF (!removeBrackets) »(«ENDIF»«
	    IF expr.m2»-«ENDIF»«
	    IF expr.t3 !== null»«compile(indent,0,lhs,expr.t3,insideWhere)»«ENDIF»«
	    FOR x:expr.t5»,«compile(indent,0,lhs,x,insideWhere)»«ENDFOR»«
	    IF (!removeBrackets) »)«ENDIF»«
	    IF expr.d»..«ENDIF»'''


	def void setNamespace(int indent,int precidence,Block expr,WhereState insideWhere) {
	    for (Statement x:expr.s)
	        setNamespace(indent+1,0,x,insideWhere);
	    if (expr.t4 !== null)
	        setNamespace(indent+1,0,expr.t4,insideWhere);
	}

	def CharSequence compileExports(int indent,int precidence,Block expr,WhereState insideWhere)
        '''
	    «IF expr.b»«
	      FOR x:expr.s»«
	        compileExports(indent+1,0,x,insideWhere)»«
	      ENDFOR»«
	    ENDIF»'''

/*PrimaryExpression returns Expr:
  (
	Literal
	|
	({Tuple} p?=KW_OPAREN m2?=KW_MINUS? (t3=WhereExpression NL? (KW_COMMA t5+=WhereExpression)*)?
    KW_CPAREN)
	|
	({Block} b?=BEGIN
		(s+=Statement NL)*
	END )
	|
	({Block} c2?=KW_OCURLY (s+=Statement NL)* KW_CCURLY )
	|
	({Block} c3?=KW_OCHEV m?=KW_MINUS? t4=WhereExpression KW_CCHEV )
	
  )
  d=KW_2DOT? // for segment with no end part */
	def CharSequence compile(int indent,int precidence,boolean lhs,Block expr,WhereState insideWhere) {
/*  	  if (insideWhere==WhereState.WritingWhere) {
	    if (expr.s === null) return "";
	    var String res = "";
	    for (Object sto:  expr.s.toArray()) {
	  	  var Statement st = sto as Statement;
	  	  //compile(indent+1,0,lhs,st,insideWhere);
	    }
	    return res
	  }*/
	  //try {
	    return
	    '''
	    «IF expr.c2»(«
	      FOR x:expr.s»«
	        newline(indent+1)»«
	        compile(indent+1,0,lhs,x,insideWhere)»«
	      ENDFOR»)«
	    ENDIF»«
	    IF expr.b»«
	      FOR x:expr.s»«
	        newline(indent+1)»«
	        compile(indent+1,0,lhs,x,insideWhere)»«
	      ENDFOR»«
	    ENDIF»«
	    IF expr.c3»«
	      IF expr.m»-«ENDIF»«
	      IF expr.t4 !== null»«compile(indent,0,lhs,expr.t4,insideWhere)»«ENDIF»«
	    ENDIF»«
	    IF expr.d»..«ENDIF»'''
	    
//	    } catch (Exception e) {
//	    	System.err.println("error "+e);
//	    	return "error "+e
//	    }
	}

    /**
     * VarOrFunction  */
	def void setNamespace(int indent,int precidence,VarOrFunction varOrFunction,WhereState insideWhere) {
      var String nam = varOrFunction.name;
      if (varOrFunction.expr !== null) {
      	setNamespace(indent,precidence,varOrFunction.expr,insideWhere)
      } else vars.addRead(nam,currentFunction);
    }

    /**
     * VarOrFunction  */
	def CharSequence compileExports(int indent,int precidence,VarOrFunction varOrFunction,WhereState insideWhere)''''''

/**
 * VarOrFunction
 * {VarOrFunction} name=TK_ID expr=UnaryExpression?)
 * If expr exists then this is usually a function
 * except if it is UnaryExpression with loc=true
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere) {
	    var boolean isVar=true;
	    if (varOrFunction.expr !== null) {
	      isVar=false;
          if (varOrFunction.expr instanceof UnaryExpression) {
	      	var UnaryExpression u = varOrFunction.expr as UnaryExpression
	      	if (u.uop == ":") isVar=true;
	      }
	    }
	    if(isVar) {
	      switch insideWhere {
	      	case NotWhere : return compileVar(indent,precidence,lhs,varOrFunction,insideWhere)
	      	case ReadingWhere : return compileVarR(indent,precidence,lhs,varOrFunction,insideWhere)
	      	case WritingWhere : return compileVarW(indent,precidence,lhs,varOrFunction,insideWhere)
	      }
	    }
	    else {
	      switch insideWhere {
	      	case NotWhere : return compileFunction(indent,precidence,lhs,varOrFunction,insideWhere)
	      	case ReadingWhere : return compileFunction(indent,precidence,lhs,varOrFunction,insideWhere)
	      	case WritingWhere : return compileFunction(indent,precidence,lhs,varOrFunction,insideWhere)
	      }
	    }
      }

	def CharSequence compileVar(int indent,int precidence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere) 
        '''
	    «cop(48,precidence)»«
	    var boolean dynamic=false»«
	    var boolean addSpace=false»«
	    var boolean global = false»«
	    var String varName = "unknown"»«
	    IF varOrFunction.expr !== null»«
	      IF (varOrFunction.expr instanceof UnaryExpression)»«
	        {addSpace=true;null}»«
	      ENDIF»«
	      {if (varOrFunction.expr instanceof UnaryExpression) dynamic= (varOrFunction.expr as UnaryExpression).loc;null}»«
	    ENDIF»«
	      {varName = cleanID(varOrFunction.name);
	      global = vars.isGlobal(varName);
	      null}»«
	      getVariable(varName,lhs)»«
	    if (addSpace) " " else ""»«
	    IF varOrFunction.expr !== null»«compile(indent,48,lhs,varOrFunction.expr,insideWhere)»«ENDIF»«
	    ccp(48,precidence)»'''

	def CharSequence compileVarR(int indent,int precidence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere) 
        '''
	    «cop(48,precidence)»«
	    cleanID(varOrFunction.name)»«
	    ccp(48,precidence)»'''

	def CharSequence compileVarW(int indent,int precidence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere) 
        '''
	    «cop(48,precidence)»«
	    cleanID(varOrFunction.name)»«
	    ccp(48,precidence)»'''


	def CharSequence compileFunction(int indent,int precidence,boolean lhs,VarOrFunction varOrFunction,WhereState insideWhere) 
        '''
	    «cop(48,precidence)»«
	    var boolean addSpace=false»«
	    IF varOrFunction.expr !== null»«
	      IF (!(varOrFunction.expr instanceof Tuple))»«
	        {addSpace=true;null}»«
	      ENDIF»«
	    ENDIF»«
	    cleanID(varOrFunction.name)»«
	    if (addSpace) " " else ""»«
	    IF varOrFunction.expr !== null»«compile(indent,48,lhs,varOrFunction.expr,insideWhere)»«ENDIF»«
	    ccp(48,precidence)»'''

/*
 * Literal:
 * // numeric literal
 * value=Numeric
 * // boolean literals
 * | bool='true'
 * | bool='false'
 *   // null
 * | nil='NIL'
 * | nil='nil'
 *   // other
 * | lst=ListLiteral
 * | lsp=LispLiteral
 * | str=TK_STRING
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,Literal literal,WhereState insideWhere)
        '''
	    «IF literal instanceof LispLiteral»«compile(indent,precidence,lhs,literal as LispLiteral,insideWhere)»«ENDIF»«
	    IF literal instanceof ListLiteral»[«compile(indent,precidence,lhs,literal as ListLiteral,insideWhere)»]«ENDIF»«
		IF literal.value !== null»«
		  literal.value»«
		  IF literal.d»..«ENDIF»«
		ENDIF»«
		IF literal.bool !== null»«literal.bool»«ENDIF»«
		IF literal.nil !== null»«literal.nil»«ENDIF»«
		IF literal.str !== null»«literal.str»«ENDIF»'''

/*
 * LispLiteral:
  p+=KW_PRIME+ sll=SubLispLiteral
  * 
  * Dont put space before prime(s) if first in a line
  * Do put space before prime(s) if following
  */
	def CharSequence compile(int indent,int precidence,boolean lhs,LispLiteral lispLiteral,WhereState insideWhere)
        '''
        «FOR x:lispLiteral.pr»«x»«ENDFOR»«
        IF lispLiteral.sll !== null»«compile(indent,precidence,lhs,lispLiteral.sll,insideWhere)»«ENDIF»'''

/*
 * SubLispLiteral:
	name=TK_ID // need to accept '%a 
	|
	// allow keywords to be used in lisp literals 
    key=('not' | 'and' | 'or' | 'for' | 'while' | 'where' | 'local' | 'package' | 'exquo' |
    'true' | 'false' | 'is' | 'isnt' | 'repeat' |'until' | 'DEFPARAMETER' | 'DEFCONST' |
    'DEFCONSTANT' | 'DEFVAR' |
	'NIL' | 'nil')
	|
	m?=KW_MINUS? num=Numeric
	|
	NL? st=TK_STRING
	|
	( NL? oparen=KW_OPAREN asl+=AnnotatedSubLispLiteral* KW_CPAREN)
  */
	def CharSequence compile(int indent,int precidence,boolean lhs,SubLispLiteral subLispLiteral,WhereState insideWhere)
        '''
	    «IF subLispLiteral.name !== null»«cleanID(subLispLiteral.name)»«ENDIF»«
	    IF subLispLiteral.m»-«ENDIF»«
	    IF subLispLiteral.num !== null»«subLispLiteral.num»«ENDIF»«
	    IF subLispLiteral.st !== null»«subLispLiteral.st»«ENDIF»«
	    IF subLispLiteral.key !== null»«subLispLiteral.key»«ENDIF»«
	    var Boolean inParen = true»«var Boolean first = true»«
	    FOR x:subLispLiteral.asl»«
	      IF x.sl !== null»«
	        IF x.sl.m »«{inParen = false;null}»«ENDIF»«
	      ENDIF»«
	      {if (!first) inParen = true;null}»«
	      {first = false;null}»«
	    ENDFOR»«
	    IF subLispLiteral.oparen && inParen»(«ENDIF»«
	    FOR x:subLispLiteral.asl»«
	      compile(indent,0,lhs,x,insideWhere)» «
	    ENDFOR»«
	    IF subLispLiteral.oparen && inParen»)«ENDIF»'''

/* AnnotatedSubLispLiteral:
 *  p?=KW_PRIME? sl=SubLispLiteral d?=KW_DOT?
 *  */
	def CharSequence compile(int indent,int precidence,boolean lhs,AnnotatedSubLispLiteral annotatedSubLispLiteral,WhereState insideWhere)
        '''
	    «IF annotatedSubLispLiteral.p»'«ENDIF»«
	    IF annotatedSubLispLiteral.sl !== null»«compile(indent,0,lhs,annotatedSubLispLiteral.sl,insideWhere)»«ENDIF»«
	    IF annotatedSubLispLiteral.d» .«ENDIF»'''

/*
 * ListLiteral:
// may be empty list so ob ensures literal is created
ob?= KW_OBRACK
le+=ListElement?
(KW_COMMA NL? le+=ListElement)*
sl+=ListComprehension*
KW_CBRACK
 */	    
	def CharSequence compile(int indent,int precidence,boolean lhs,ListLiteral listLiteral,WhereState insideWhere)
        '''
        «var testparams=false»«
        FOR x:listLiteral.le»«if(testparams)','»«compile(indent,0,lhs,x,insideWhere)»«{testparams=true;null}»«ENDFOR»«
        FOR x:listLiteral.sl»«compile(indent,0,lhs,x,insideWhere)»«ENDFOR»'''

/*
 * ListElement:
	(
		(c?=KW_COLON? e?=KW_EQ)? l2=IfExpression |
		c2?=KW_COLON? d?=KW_DOT
	)
 */
	def CharSequence compile(int indent,int precidence,boolean lhs,ListElement listElement,WhereState insideWhere)
        '''
        «IF listElement.c»:«
          IF listElement.e» «ENDIF»«
        ENDIF»«
        IF listElement.e»=«ENDIF»«
        IF listElement.l2 !== null»«compile(indent,0,lhs,listElement.l2,insideWhere)» «ENDIF»«
        IF listElement.c2»:«ENDIF»«
        IF listElement.d».«ENDIF»'''

/*
 * ListComprehension:
  (sl1=('for'|'while'|'where'|KW_BAR) sl2=Expression
  	|
  	r?='repeat'
  )
 */	    
	def CharSequence compile(int indent,int precidence,boolean lhs,ListComprehension listComprehension,WhereState insideWhere)
        '''
        «IF listComprehension.sl1 !== null» «listComprehension.sl1» «ENDIF»«
	    IF listComprehension.sl2 !== null»«compile(indent,0,lhs,listComprehension.sl2,insideWhere)»«ENDIF»«
	    IF listComprehension.r» repeat «ENDIF»'''
}
/* Code Generator Template Notes
 * -----------------------------
 * Template commands:
 * 
 * FOR
 * ENDFOR
 * IF
 * ELSE
 * ENDIF
 * ELSEIF
 * 
 * To display filename use:
 *      «IF function.eContainer !== null»
 *           function «function.eResource.className»;
 *      «ENDIF»
 *
 * To use Booleans:
 *
 *    «IF block.b»true«ELSE»false«ENDIF»
 */
