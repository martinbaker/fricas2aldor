/*
 * generated by Xtext 2.12.0
 */
package com.euclideanspace.bootSyntax.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.euclideanspace.bootSyntax.editor.Model
import com.euclideanspace.bootSyntax.editor.Declaration
import com.euclideanspace.bootSyntax.editor.Package
import com.euclideanspace.bootSyntax.editor.Comment
import com.euclideanspace.bootSyntax.editor.Documentation
import com.euclideanspace.bootSyntax.editor.Defparameter
import com.euclideanspace.bootSyntax.editor.Defconstant
import com.euclideanspace.bootSyntax.editor.Defconst
import com.euclideanspace.bootSyntax.editor.Defvar
import com.euclideanspace.bootSyntax.editor.FunctionDef
import com.euclideanspace.bootSyntax.editor.GlobalVariable
import com.euclideanspace.bootSyntax.editor.Statement
import com.euclideanspace.bootSyntax.editor.Loop
import com.euclideanspace.bootSyntax.editor.LoopCondition
//import com.euclideanspace.bootSyntax.editor.While
import com.euclideanspace.bootSyntax.editor.Do
//import com.euclideanspace.bootSyntax.editor.Until
//import com.euclideanspace.bootSyntax.editor.For
import com.euclideanspace.bootSyntax.editor.Where
import com.euclideanspace.bootSyntax.editor.Expr
import com.euclideanspace.bootSyntax.editor.Expression
import com.euclideanspace.bootSyntax.editor.ExitExpression
import com.euclideanspace.bootSyntax.editor.OrExpression
import com.euclideanspace.bootSyntax.editor.AndExpression
import com.euclideanspace.bootSyntax.editor.EqualityExpression
import com.euclideanspace.bootSyntax.editor.RelationalExpression
import com.euclideanspace.bootSyntax.editor.IsExpression
import com.euclideanspace.bootSyntax.editor.InExpression
import com.euclideanspace.bootSyntax.editor.SegmentExpression
import com.euclideanspace.bootSyntax.editor.AdditiveExpression
import com.euclideanspace.bootSyntax.editor.ExquoExpression
import com.euclideanspace.bootSyntax.editor.DivisionExpression
import com.euclideanspace.bootSyntax.editor.QuoExpression
import com.euclideanspace.bootSyntax.editor.ModExpression
import com.euclideanspace.bootSyntax.editor.RemExpression
import com.euclideanspace.bootSyntax.editor.MultiplicativeExpression
import com.euclideanspace.bootSyntax.editor.ExponentExpression
import com.euclideanspace.bootSyntax.editor.MapExpression
import com.euclideanspace.bootSyntax.editor.AssignExpression
import com.euclideanspace.bootSyntax.editor.EltExpression
import com.euclideanspace.bootSyntax.editor.UnaryExpression
import com.euclideanspace.bootSyntax.editor.VarOrFunction
import com.euclideanspace.bootSyntax.editor.Tuple
import com.euclideanspace.bootSyntax.editor.Literal
import com.euclideanspace.bootSyntax.editor.LispLiteral
import com.euclideanspace.bootSyntax.editor.SubLispLiteral
import com.euclideanspace.bootSyntax.editor.AnnotatedSubLispLiteral
import com.euclideanspace.bootSyntax.editor.ListLiteral
import com.euclideanspace.bootSyntax.editor.ListElement
import com.euclideanspace.bootSyntax.editor.ListComprehension
import com.euclideanspace.bootSyntax.editor.WhereExpression
import com.euclideanspace.bootSyntax.editor.IfExpression
import com.euclideanspace.bootSyntax.editor.LambdaExpression
import com.euclideanspace.bootSyntax.editor.Block
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 *
 * @see <a href="http://www.euclideanspace.com/prog/spad2aldor/boot/index.htm">compiling Boot code</a>
 * @author Martin Baker
 */
class EditorGenerator extends AbstractGenerator {

    var static GlobalScope vars = null;
    /* track the file, package and function as we walk the tree. Its a bit
     * of a hack tracking them this way but its more efficient than passing
     * in every function*/
    var String currentFile ="";
    var String currentFunction ="";
//    var String bootPkg ="";
    /** When walking the tree we cant insert because that could be
    * unstable, so store list of injects for later.*/
    Injects inj = new Injects();

    /** print free memory, runs garbage collection twice to make sure all free
     * memory is counted.
     * Used for debugging only */
 	def printMem() {
 		System.gc();
 		System.gc();
 		System.out.println("mem free "+Runtime.getRuntime().freeMemory());
 	}

    override void beforeGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
 	  //System.out.print("*");
      if (vars === null) {
 	    //System.out.println("beforeGenerate ");
      	vars = new GlobalScope(null,null,null)
        val ResourceSet rs = resource.resourceSet;
        val EList<Resource> res = rs.getResources();
        for (Resource r:res) {
          val String fileName = className(r);// sets currentFile
          var EObject m = r.contents.head;
          if (m instanceof Model) {
            //printMem();
            val NamespaceScope ns = setNamespace(vars,m as Model);
            if (ns instanceof FileScope) {
            	val FileScope fs = ns as FileScope;
            	fs.setFileName(fileName);
            }
          }
        }
        // inject extra nodes into tree that cant be done when walking tree
        inj.doIt();
        // Now that scope tree is complete we can walk the tree to make sure
        // all links are resolved
        if (!vars.resolveLinks()) System.err.println("EditorGenerator: error in resolve");
        // generateFile takes CharSequence so showDefs and showScopes return StringBuilder
        fsa.generateFile("namespace.txt",vars.showDefs())
        fsa.generateFile("scopes.txt",vars.showScopes(0))
      }
    }

    def GlobalScope getVars() {
    	return vars;
    }

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
 	  //System.out.print(".");
      if (vars === null) {
      	System.err.println("EditorGenerator: doGenerate called before vars setup:"+resource.className);
      	return;
      }
      val String filename = className(resource); // sets currentFile
      //System.out.println("currentFile="+currentFile+" import="+vars.importList(currentFile));
      if ("apply".equals(filename))
        fsa.generateFile(resource.className+".spad", compile(0,0,false,resource.contents.head as Model,vars))
    }

    /** set currentFile which is package name*/
 	def className(Resource res) {
		var name = res.URI.lastSegment
		currentFile = name.substring(0, name.indexOf('.'))
		return currentFile;
	}

    /**
     * converts long filename to format used by old Microsoft OS
     * Used by compile(Model)
     */
	def String shortName(String a) {
		var int last=4;
		var String b = a.replaceAll("-","");
		b = b.replaceAll("_","");
		if (b.length()<4) last= b.length();
		"BOOL"+b.substring(0,last).toUpperCase();
	}

    /**
     * Model
     */
	def CharSequence compile(int indent,int precedence,boolean lhs,Model model,NamespaceScope parentScope)
	    '''
	    «if (!(parentScope instanceof GlobalScope)){
	    	System.err.println("compile model expects parentScope to be GlobalScope")
	    	System.err.println("parentScope="+parentScope)
	    }»«
	    var String longName = "** no resource **"»«
	    IF model.eResource !== null»«{longName = model.eResource.className;null}»«
	    ENDIF»)abbrev package «shortName(longName)» «longName»
	    «longName»() : Exports == Implementation where«
	    compileExports(indent+1,precedence,model)»«
	    compileImplementation(indent+1,precedence,model)»'''

    /**
     * Model
     * used by beforeGenerate
     */
	def NamespaceScope setNamespace(GlobalScope parent,Model model) {
		val FileScope ns = new FileScope(parent,currentFile);
		parent.addSubscope(ns);
		for (Declaration x: model.declarations) {
		  setNamespace(ns,x);
		}
		return ns;
	}

    /**
     * Model
     */
	def CharSequence compileExports(int indent,int precedence,Model model)
	    '''
	    «vars.getPackage(currentFile).outputSPADExports(indent,precedence)»'''

    /**
     * Model
     */
	def CharSequence compileImplementation(int indent,int precedence,Model model)
	    '''
	    «vars.getPackage(currentFile).outputSPAD(indent,precedence,false)»'''

    /**
     * Declaration
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Declaration declaration) {
	    if (declaration instanceof Package)
	       return setNamespace(parent,declaration as Package)
		if (declaration instanceof Comment)
	       return setNamespace(parent,declaration as Comment)
		if (declaration instanceof Documentation)
	       return setNamespace(parent,declaration as Documentation)
		if (declaration instanceof Defparameter)
	       return setNamespace(parent,declaration as Defparameter)
	    if (declaration instanceof Defconstant)
	       return setNamespace(parent,declaration as Defconstant)
	    if (declaration instanceof Defconst)
	       return setNamespace(parent,declaration as Defconst)
	    if (declaration instanceof Defvar)
	       return setNamespace(parent,declaration as Defvar)
	    if (declaration instanceof FunctionDef)
	       return setNamespace(parent,declaration as FunctionDef)
	    if (declaration instanceof Where)
	       return setNamespace(parent,declaration as Where)
	    if (declaration instanceof GlobalVariable)
	       return setNamespace(parent,declaration as GlobalVariable)
	    return new NullScope(null,null);
	}
	
	/** Package */
	def NamespaceScope setNamespace(NamespaceScope parent,Package package1) {
		if (package1.p !== null) {
//			bootPkg = package1.p;
			if (parent instanceof FileScope) (parent as FileScope).setPackageName(package1.p); 
		}
      // dont need separate node for package statement.
      return new NullScope(null,null);
    }

    /** Comment */
	def NamespaceScope setNamespace(NamespaceScope parent,Comment comment) {
		var CommentScope ns = null;
		if (parent instanceof FileScope) {
		  val FileScope p = parent as FileScope;
		  val DeclarationScope lst = p.lastDeclaration();
		  if (lst instanceof CommentScope) {
		    ns = lst as CommentScope;
		    ns.addComment(comment.c);
		  } else {
		    ns = new CommentScope(parent,null);
		    ns.addComment(comment.c);
		    p.addDeclaration(ns);
		  }
		} else {
		  ns = new CommentScope(parent,null);
		  ns.addComment(comment.c);			
		}
	    return ns;
    }

    /** Documentation */
	def NamespaceScope setNamespace(NamespaceScope parent,Documentation documentation) {
		var CommentScope ns = null;
		if (parent instanceof FileScope) {
			val FileScope p = parent as FileScope;
			val DeclarationScope lst = p.lastDeclaration();
			if (lst instanceof CommentScope) {
				ns = lst as CommentScope;
			}
		    else {
		    	ns = new CommentScope(parent,null);
		    	parent.addSubscope(ns);
		    }
			p.addDeclaration(ns);
		}
	    if (documentation.e !== null) {
	      val NamespaceScope e=setNamespace(ns,documentation.e);
	      ns.setSwitch(e,documentation.ei);
	    }
	    return ns;
    }
 
    /**
     * Defparameter
     * 'DEFPARAMETER' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Defparameter defparameter) {
		val String nam = defparameter.name
		val VariableDefScope ns = new VariableDefScope(parent,nam);
		parent.addSubscope(ns);
		ns.addVariableDef(new VariableSpec(nam,ns,VariableType.Defparameter));
		if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	    return ns;
    }

    /**
     * Defconstant
     * 'DEFCONSTANT' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Defconstant defconstant) {
		val String nam = defconstant.name
		val VariableDefScope ns = new VariableDefScope(parent,nam);
		parent.addSubscope(ns);
		ns.addVariableDef(new VariableSpec(nam,ns,VariableType.Defconstant));
		if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	    return ns;
	}

    /**
     * Defconst
     * 'DEFCONST' KW_OPAREN name=TK_ID KW_COMMA e=Expression KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Defconst defconst) {
		val String nam = defconst.name
		val VariableDefScope ns = new VariableDefScope(parent,nam);
		parent.addSubscope(ns);
		ns.addVariableDef(new VariableSpec(nam,ns,VariableType.Defconst));
		if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	    return ns;
	}

    /**
     * Defvar
     * 'DEFVAR' KW_OPAREN name=TK_ID (KW_COMMA e=Expression)? KW_CPAREN;
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Defvar defvar) {
		val String nam = defvar.name
		val VariableDefScope ns = new VariableDefScope(parent,nam);
		parent.addSubscope(ns);
		ns.addVariableDef(new VariableSpec(nam,ns,VariableType.Defvar));
		if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	    return ns;
	}

    /**
     * FunctionDef
     */
	def NamespaceScope setNamespace(NamespaceScope parent,FunctionDef function){
	    if (function.name !== null) {
	      currentFunction = function.name;
        }
		val FunctionDefScope ns = new FunctionDefScope(parent,currentFunction);
		parent.addSubscope(ns);
		// setup parameters
        var ArrayList<VariableTree> params = new ArrayList<VariableTree>();
        for (Expr p:function.params) {
          var String nm = "unknown name";
          //if (p != null) nm = p.display();
          var ParameterScope ps = new ParameterScope(ns,nm);
          ns.addParameter(ps);
          ns.addSubscope(ps);
          val NamespaceScope parSc = setNamespace(ns,p)
          ps.addParameterInfo(parSc);
        }
        // alternative is single parameter given by juxtaposition.
        if (function.j !== null) {
          val VariableTree par = new VariableTree(function.j,null);
          if (par !== null) params.add(par);
        }
        ns.addFunctionDef(function.name,null,params,0,(function.fp).size());
        // statements which may be a block
	    if (function.st !== null) {
	      val NamespaceScope c = setNamespace(ns,function.st);
          ns.setStatement(c);
	    }
	    if (function.w !== null) {
	      val NamespaceScope w = setNamespace(ns,function.w)
	      ns.setWhere(w);
	    }
		if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	    return ns;
	}

   /**
    * Global Lexical Variable
    * A variable assignment outside scope of a function definition
    */
	def NamespaceScope setNamespace(NamespaceScope parent,GlobalVariable globalVariable) {
	  val VariableDefScope ns = new VariableDefScope(parent,null);
	  parent.addSubscope(ns);
      if (globalVariable.name !== null) ns.addVariableDef(new VariableSpec(globalVariable.name,ns,VariableType.LexGlobal));
	  if (globalVariable.e !== null) {
	      val NamespaceScope e = setNamespace(ns,globalVariable.e);
	      ns.setInitialValue(e);
	  }
	  if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
      return ns;
    }

/*
 * Statement:
 *  ( Comment | Loop  |  WhereExpression  | Where | Do)
 */
	def NamespaceScope setNamespace(NamespaceScope parent,Statement statement) {
	  if (statement instanceof Comment)
	       return setNamespace(parent,statement as Comment);
	  if (statement instanceof Loop)
	       return setNamespace(parent,statement as Loop);
	  if (statement instanceof Do)
	       return setNamespace(parent,statement as Do);
      if (statement instanceof Where)
	       return setNamespace(parent,statement as Where);
	  if (statement instanceof Expr)
	       return setNamespace(parent,statement as Expr);
	  return new NullScope(null,null);
    }

/**
 * Loop:
 * c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block
 * 
 * Put space after each condition.
 * This code uses LoopCondition, While, For and Until directly rather
 * than calling their 'compile' functions. This is because trailing spaces
 * after newline are changed by auto-indent code.
 *
 */
	def NamespaceScope setNamespace(NamespaceScope parent,Loop loop) {
		val LoopScope ns = new LoopScope(parent,null);
	    parent.addSubscope(ns);
        for(LoopCondition x:loop.c) {
          var NamespaceScope lc = null;
          var String op = null;
          if (x.f !== null) {
            if (x.f.e !== null) {
            	lc=setNamespace(ns,x.f.e);
            	op = "for";
            }
          }
          if (x.w !== null) {
            if (x.w.e !== null) {
            	lc=setNamespace(ns,x.w.e);
            	op = "while";
            }
          }
          if (x.u !== null) {
            if (x.u.e !== null) {
            	lc=setNamespace(ns,x.u.e);
            	op = "until";
            }
          }
          ns.addCondition(new LoopCond(lc,op));
        }
        var NamespaceScope bar = null;
        var NamespaceScope repeatBlock = null;
        if (loop.e !== null) {
          bar=setNamespace(ns,loop.e);
        }
        if (loop.b !== null) {
          repeatBlock=setNamespace(ns,loop.b);
        }
        ns.setLoop(bar,repeatBlock);
        return ns;
      }

/*
 * Do:
 * 'do' b=Block
 */
	def NamespaceScope setNamespace(NamespaceScope parent,Do do1) {
		val LoopScope ns = new LoopScope(parent,null);
	    parent.addSubscope(ns);
        var NamespaceScope lc = null;
        var String op = null;
        if (do1.e !== null) lc=setNamespace(ns,do1.e);
        ns.addCondition(new LoopCond(lc,op));
        return ns;
    }

    /**
     * Where
     * 
     * The namespace in the 'Where' is in its original position
     * but we also want to move the code outside the function.
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Where where) {
	  val WhereScope ns = new WhereScope(parent,null);
	  parent.addSubscope(ns as NamespaceScope);
	  if (where.b !== null) {
	  	// cant setup a link to WhereScope yet because it has not yet been set.
	  	val NamespaceScope content=setNamespace(ns,where.b);
	  	ns.setContent(content);
	  	val UseMarkerScope ums = new UseMarkerScope(null,null,null,ns);
	  	inj.addInject(ns.getEnclosingFnDef(),ums);
	  }
	  if (parent instanceof FileScope) (parent as FileScope).addDeclaration(ns);
	  return ns;
    }

    /** Expr */
	def NamespaceScope setNamespace(NamespaceScope parent,Expr expr) {
        //System.err.println("EditorGenerator.setNamespace expr="+expr);		
        if (expr instanceof WhereExpression) return setNamespace(parent,expr as WhereExpression);
	    if (expr instanceof IfExpression) return setNamespace(parent,expr as IfExpression);
	    if (expr instanceof Expression) return setNamespace(parent,expr as Expression);
	    if (expr instanceof OrExpression) return setNamespace(parent,expr as OrExpression);
	    if (expr instanceof AndExpression) return setNamespace(parent,expr as AndExpression);
	    if (expr instanceof EqualityExpression) return setNamespace(parent,expr as EqualityExpression);
	    if (expr instanceof RelationalExpression) return setNamespace(parent,expr as RelationalExpression);
	    if (expr instanceof IsExpression) return setNamespace(parent,expr as IsExpression);
	    if (expr instanceof InExpression) return setNamespace(parent,expr as InExpression);
        if (expr instanceof SegmentExpression) return setNamespace(parent,expr as SegmentExpression);
        if (expr instanceof AdditiveExpression) return setNamespace(parent,expr as AdditiveExpression);
        if (expr instanceof ExquoExpression) return setNamespace(parent,expr as ExquoExpression);
        if (expr instanceof DivisionExpression) return setNamespace(parent,expr as DivisionExpression);
        if (expr instanceof QuoExpression) return setNamespace(parent,expr as QuoExpression);
        if (expr instanceof ModExpression) return setNamespace(parent,expr as ModExpression);
        if (expr instanceof RemExpression) return setNamespace(parent,expr as RemExpression);
        if (expr instanceof MultiplicativeExpression) return setNamespace(parent,expr as MultiplicativeExpression);
        if (expr instanceof ExponentExpression) return setNamespace(parent,expr as ExponentExpression);
        if (expr instanceof MapExpression) return setNamespace(parent,expr as MapExpression);
	    if (expr instanceof LambdaExpression) return setNamespace(parent,expr as LambdaExpression);
	    if (expr instanceof AssignExpression) return setNamespace(parent,expr as AssignExpression);
	    if (expr instanceof ExitExpression) return setNamespace(parent,expr as ExitExpression);
        if (expr instanceof EltExpression) return setNamespace(parent,expr as EltExpression);
        if (expr instanceof UnaryExpression) return setNamespace(parent,expr as UnaryExpression);
	    if (expr instanceof VarOrFunction) return setNamespace(parent,expr as VarOrFunction);
	    if (expr instanceof Tuple) return setNamespace(parent,expr as Tuple);
	    if (expr instanceof Block) return setNamespace(parent,expr as Block);
	    if (expr instanceof Literal) return setNamespace(parent,expr as Literal);
        if (expr.b1 !== null) {
          val IfScope ns = new IfScope(parent,null);
          var NamespaceScope ifPart = null;
          var NamespaceScope thenPart = null;
          var NamespaceScope elsePart = null;
	      parent.addSubscope(ns);
	      ifPart = setNamespace(ns,expr.b1);
          if (expr.b2 !== null) thenPart = setNamespace(ns,expr.b2);
          if (expr.b2i !== null) thenPart = setNamespace(ns,expr.b2i);
          if (expr.b3 !== null) elsePart = setNamespace(ns,expr.b3);
          ns.setExpressions(ifPart,thenPart,elsePart);
          return ns;
        }
        return new NullScope(null,null);
    }

    /** WhereExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,WhereExpression whereExpression) {
	  val WhereExprScope ns = new WhereExprScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope left = null;
	  var NamespaceScope wh = null;
      if (whereExpression.left !== null) left=setNamespace(ns,whereExpression.left);
	  if (whereExpression.w !== null) wh=setNamespace(ns,whereExpression.w);
	  ns.setContent(left,wh);
	  return ns;
    }

    /**
     * IfExpression 
     * IfExpression returns Expr:
     * Expression
     * |
     * ({IfExpression} KW_AT 'if' i1=Expression 'then' i2=Statement NL? ('else' i3=Statement NL?)? KW_AT)
     */
	def NamespaceScope setNamespace(NamespaceScope parent,IfExpression ifExpression) {
	  val IfScope ns = new IfScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope ifPart = null;
      var NamespaceScope thenPart = null;
      var NamespaceScope elsePart = null;
      if(ifExpression.i1 !== null) ifPart = setNamespace(ns,ifExpression.i1);
      if(ifExpression.i2 !== null) thenPart = setNamespace(ns,ifExpression.i2);
      if(ifExpression.i3 !== null) elsePart = setNamespace(ns,ifExpression.i3);
      ns.setExpressions(ifPart,thenPart,elsePart);
      return ns;
    }

 /* Expression
 * This is top of expression tree except for WhereExpression
 * combines statements using semicolon.
 * 
 * Holds two statements separated by semicolon.
 * 
 * 'right2' is enclosed in braces.
 */
	def NamespaceScope setNamespace(NamespaceScope parent,Expression expression) {
	  val BlockScope ns = new BlockScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope expr = null;
	  if(expression.left !== null) {
	  	expr = setNamespace(ns,expression.left);
	  	ns.addStatement(expr);
	  }
	  if(expression.right !== null) {
	  	expr = setNamespace(ns,expression.right);
	  	ns.addStatement(expr);
	  }
	  if(expression.right2 !== null) {
	  	expr = setNamespace(ns,expression.right2);
	  	ns.addStatement(expr);
	  }
	  return ns;
	}

    /** MapExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,MapExpression mapExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(mapExpression.left !== null) lft = setNamespace(ns,mapExpression.left);
	  if(mapExpression.right !== null) rht = setNamespace(ns,mapExpression.right);
	  ns.setBinOp(10,lft,rht,mapExpression.op);
	  return ns;
	}

/** LambdaExpression :
 * 
 * LambdaExpression returns Expr:
 * ExitExpression
 * ({LambdaExpression.left=current} op=KW_EQ2 (
 * right = ExitExpression
 * )
 * )*
*/
	def NamespaceScope setNamespace(NamespaceScope parent,LambdaExpression lambdaExpression) {
		var String fnNam = "lambda"
		val FunctionDefScope ns = new FunctionDefScope(parent,fnNam);
	    parent.addSubscope(ns);
//        var VarOrFunction v =null;
//        var fnName="";
        if (lambdaExpression.left instanceof VarOrFunction) {
          var SignatureScope lft = compileSignature(ns as NamespaceScope,lambdaExpression.left as VarOrFunction);
          ns.initialiseParams(lft.getName(),lft.getParameters());
        } else {
        	System.err.println("EditorGenerator.setNamespace.Lambda lft not VarOrFunction:"+lambdaExpression.left);
/*           // this holds function name and parameters so initialise it
          if (lft instanceof FunctionCallScope) {
            val FunctionCallScope fcs=lft as FunctionCallScope;
            //System.out.println("EditorGenerator.setNamespace.Lambda fcs="+fcs)
            fcs.initialiseLambda();
          } else if (lft instanceof VarCallScope) {
            val VarCallScope vcs=lft as VarCallScope;
            //System.out.println("EditorGenerator.setNamespace.Lambda vcs="+vcs)
            vcs.initialiseLambda();
          } else {
            System.out.println("EditorGenerator.setNamespace.Lambda lft="+lft)          	
          }*/
/*
          if (lft instanceof ParameterScope) {
          	//TODO remove this option, I dont think its used
          	ns.addParameter(lft);
            System.out.println("EditorGenerator.setNamespace.Lambda lft="+lft)
          } else if (lambdaExpression.left instanceof VarOrFunction) {
            v=lambdaExpression.left as VarOrFunction
            var NamespaceScope pars = setNamespace(lft,v);
            //lft.addSubscope(pars);
System.out.println("EditorGenerator.setNamespace.Lambda pars="+pars)
*/


		  // setup parameters
/*          var ArrayList<VariableTree> params = new ArrayList<VariableTree>();
          for (Expr p:function.params) {
            var String nm = "unknown name";
            //if (p != null) nm = p.display();
            var ParameterScope ps = new ParameterScope(ns,nm);
            ns.addParameter(ps);
            ns.addSubscope(ps);
            val NamespaceScope parSc = setNamespace(ns,p)
            ps.addParameterInfo(parSc);
          }*/



 /*            if (v !== null) {
            	fnName=v.name;
            	var ArrayList<VariableTree> params = null;
            	if (v.expr instanceof Tuple) {
            		val Tuple t = v.expr as Tuple;
            		//params = typeFromTuple(t);
            	}
            	ns.addFunctionDef(fnName,currentFunction,params,0,0);
            }
          }*/
        }
        if (lambdaExpression.right !== null) {
          var NamespaceScope rht = setNamespace(ns,lambdaExpression.right);
          ns.setStatement(rht);	
        }
        var WhereScope w = null;
        if (parent !== null) w = parent.getWhereAncestor();
        //System.out.println("Lambda WhereAncestor="+w)
        if (w !== null) w.setInnerFnDef(ns);
        return ns;
    }

/* ExitExpression
 * 
 * This is top of expression tree except for WhereExpression
 * Handles exit like: '=>' expr1 ';' expr2
 */
	def NamespaceScope setNamespace(NamespaceScope parent,ExitExpression exitExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
      if (exitExpression.left !== null) lft=setNamespace(ns,exitExpression.left);
	  if (exitExpression.right !== null) rht=setNamespace(ns,exitExpression.right);
	  ns.setBinOp(14,lft,rht,exitExpression.op);
	  return ns;
    }

    /**
     * AssignExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,AssignExpression assignExpression) {
      //System.err.println("EditorGenerator.setNamespace assign");
	  val AssignScope ns = new AssignScope(parent,null);
	  parent.addSubscope(ns);
 	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
      if (assignExpression.left !== null) {
	    lft=setNamespace(ns,assignExpression.left);
        if (assignExpression.left instanceof VarOrFunction) {
          val VarOrFunction v = assignExpression.left as VarOrFunction;
	      val VariableTree lt = new VariableTree(v.name,null);
	      ns.initVariable(lt);
        } else if (assignExpression.left instanceof ListLiteral) {
          val ListLiteral ll = assignExpression.left as ListLiteral;
	      val VariableTree lt = new VariableTree(ll,new ArrayList<Integer>());
	      ns.initVariable(lt);
        } else if (assignExpression.left instanceof AssignExpression) {
          //val AssignExpression agn = assignExpression.left as AssignExpression;
          //val NamespaceScope agnn = setNamespace(ns,agn);
          ns.initVariableNestedAssign(lft);
        } else if (assignExpression.left instanceof EltExpression) {
          //val EltExpression elt = assignExpression.left as EltExpression;
          //val NamespaceScope eltn = setNamespace(ns,elt);
          ns.initVariableElt(lft);
        } else {
          System.err.println("EditorGenerator.setNamespace unexpected subnode in assign: "+assignExpression.left);
        }
	  }
	  if (assignExpression.right !== null) {
	    rht=setNamespace(ns,assignExpression.right);
	  }
	  ns.setBinOp(16,lft,rht,assignExpression.op);
	  return ns;
	}

    /**
     * OrExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,OrExpression orExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(orExpression.left !== null) lft=setNamespace(ns,orExpression.left);
	  if(orExpression.right !== null) rht=setNamespace(ns,orExpression.right);
	  ns.setBinOp(18,lft,rht,orExpression.op);
	  return ns;
	}

    /**
     * AndExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,AndExpression andExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(andExpression.left !== null) lft=setNamespace(ns,andExpression.left);
	  if(andExpression.right !== null) rht=setNamespace(ns,andExpression.right);
	  ns.setBinOp(20,lft,rht,andExpression.op);
	  return ns;
	}

    /**
     * EqualityExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,EqualityExpression equalityExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(equalityExpression.left !== null) lft=setNamespace(ns,equalityExpression.left);
	  if(equalityExpression.right !== null) rht=setNamespace(ns,equalityExpression.right);
	  ns.setBinOp(20,lft,rht,equalityExpression.op);
	  return ns;
	}

    /**
     * RelationalExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,RelationalExpression relationalExpression) {
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(relationalExpression.left !== null) lft=setNamespace(ns,relationalExpression.left);
	  if(relationalExpression.right !== null) rht=setNamespace(ns,relationalExpression.right);
	  ns.setBinOp(20,lft,rht,relationalExpression.op);
	  return ns;
	}

    /**
     * IsExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,IsExpression isExpression){
      //System.err.println("EditorGenerator.setNamespace is begin");
	  val IsScope ns = new IsScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(isExpression.left !== null)
	      lft=setNamespace(ns,isExpression.left);
	  if(isExpression.right !== null) {
          rht=setNamespace(ns,isExpression.right);
          if (isExpression.right instanceof ListLiteral) {
            val ListLiteral ll = (isExpression.right as ListLiteral);
	        val VariableTree lt = new VariableTree(ll,new ArrayList<Integer>());
	        // following is to trigger extra lines in SPAD code.
	        ns.initVariable(lt);
          } else if (isExpression.right instanceof LispLiteral) {
            //val LispLiteral lpl = (isExpression.right as LispLiteral);
            //val NamespaceScope lpln = setNamespace(ns,lpl);
            ns.initIsLispLiteral(rht);
          } else if (isExpression.right instanceof Literal) {
            //val Literal lit = (isExpression.right as Literal);
            //val NamespaceScope litn = setNamespace(ns,lit);
            ns.initIsLiteral(rht);
          } else if (isExpression.right instanceof VarOrFunction) {
            //val Literal lit = (isExpression.right as Literal);
            //val NamespaceScope litn = setNamespace(ns,lit);
            ns.initIsVariable(rht);
          } else {
            System.err.println("EditorGenerator.setNamespace unexpected subnode in 'is': "+isExpression.right);
          }
      }
	  ns.setBinOp(26,lft,rht,isExpression.op);
      //System.err.println("EditorGenerator.setNamespace is end");
      if (ns === null) {
		System.err.println("EditorGenerator.setNamespace(is): ns == null");
	  }
      return ns;
	}

    /**
     * InExpression
     */
	def NamespaceScope setNamespace(NamespaceScope parent,InExpression inExpression) {
		val BinaryOpScope ns = new BinaryOpScope(parent,null);
	    parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  var NamespaceScope by = null;
	    if(inExpression.left !== null)
          if (inExpression.left instanceof VarOrFunction) {
          	val VarOrFunction v = inExpression.left as VarOrFunction;
          	ns.addVariableCall(v.name,true);
          }
	      lft=setNamespace(ns,inExpression.left);
	    if(inExpression.right !== null) rht=setNamespace(ns,inExpression.right);
	    if(inExpression.r2 !== null) by=setNamespace(ns,inExpression.r2);
	    ns.setBinOp(28,lft,rht,inExpression.op);
	    ns.setBy(by);
	    return ns;
	}

    /**
     * SegmentExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,SegmentExpression segmentExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(segmentExpression.left !== null)
	      lft=setNamespace(ns,segmentExpression.left);
	  if(segmentExpression.right !== null)
	      rht=setNamespace(ns,segmentExpression.right);
	  ns.setBinOp(30,lft,rht,segmentExpression.op);
	  return ns;
	}

    /**
     * AdditiveExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,AdditiveExpression additiveExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(additiveExpression.left !== null)
	      lft=setNamespace(ns,additiveExpression.left);
	  if(additiveExpression.right !== null)
	      rht=setNamespace(ns,additiveExpression.right);
	  ns.setBinOp(32,lft,rht,additiveExpression.op);
	  return ns;
	}

    /**
     * ExquoExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,ExquoExpression exquoExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(exquoExpression.left !== null)
	      lft=setNamespace(ns,exquoExpression.left);
	  if(exquoExpression.right !== null)
	      rht=setNamespace(ns,exquoExpression.right);
	  ns.setBinOp(34,lft,rht,exquoExpression.op);
	  return ns;
	}

    /**
     * DivisionExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,DivisionExpression divisionExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(divisionExpression.left !== null)
	      lft=setNamespace(ns,divisionExpression.left);
	  if(divisionExpression.right !== null)
	      rht=setNamespace(ns,divisionExpression.right);
	  ns.setBinOp(36,lft,rht,divisionExpression.op);
	  return ns;
	}

    /**
     * QuoExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,QuoExpression quoExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(quoExpression.left !== null)
	      lft=setNamespace(ns,quoExpression.left);
	  if(quoExpression.right !== null)
	      rht=setNamespace(ns,quoExpression.right);
	  ns.setBinOp(16,lft,rht,quoExpression.op);
	  return ns;
	}

    /**
     * ModExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,ModExpression modExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(modExpression.left !== null)
	      lft=setNamespace(ns,modExpression.left);
	  if(modExpression.right !== null)
	      rht=setNamespace(ns,modExpression.right);
	  ns.setBinOp(38,lft,rht,modExpression.op);
	  return ns;
	}

    /**
     * RemExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,RemExpression remExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(remExpression.left !== null)
	      lft=setNamespace(ns,remExpression.left);
	  if(remExpression.right !== null)
	      rht=setNamespace(ns,remExpression.right);
	  ns.setBinOp(40,lft,rht,remExpression.op);
	  return ns;
	}

    /**
     * MultiplicativeExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,MultiplicativeExpression multiplicativeExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(multiplicativeExpression.left !== null)
	      lft=setNamespace(ns,multiplicativeExpression.left);
	  if(multiplicativeExpression.right !== null)
	      rht=setNamespace(ns,multiplicativeExpression.right);
	  ns.setBinOp(42,lft,rht,multiplicativeExpression.op);
	  return ns;
	}

    /**
     * ExponentExpression  */
	def NamespaceScope setNamespace(NamespaceScope parent,ExponentExpression exponentExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(exponentExpression.left !== null)
	      lft=setNamespace(ns,exponentExpression.left);
	  if(exponentExpression.right !== null)
	      rht=setNamespace(ns,exponentExpression.right);
	  ns.setBinOp(44,lft,rht,exponentExpression.op);
	  return ns;
	}

    /**
     * EltExpression  */
	def NamespaceScope setNamespace(NamespaceScope parent,EltExpression eltExpression){
	  val BinaryOpScope ns = new BinaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope lft = null;
	  var NamespaceScope rht = null;
	  if(eltExpression.left !== null)
	      lft=setNamespace(ns,eltExpression.left);
	  if(eltExpression.right !== null)
	      rht=setNamespace(ns,eltExpression.right);
	  ns.setBinOp(46,lft,rht,eltExpression.op);
	  return ns;
	}

    /** UnaryExpression */
	def NamespaceScope setNamespace(NamespaceScope parent,UnaryExpression unaryExpression) {
	  val UnaryOpScope ns = new UnaryOpScope(parent,null);
	  parent.addSubscope(ns);
	  var NamespaceScope b1 = null;
	  var NamespaceScope b3 = null;
	  var NamespaceScope expr = null;
	  if (unaryExpression.b1 !== null) {
 	    b1=setNamespace(ns,unaryExpression.b1);
 	    System.err.println("EditorGenerator.setNamespace error "+unaryExpression.b1);
 	  }
	  if (unaryExpression.b3 !== null) {
	  	b3=setNamespace(ns,unaryExpression.b3);
 	    System.err.println("EditorGenerator.setNamespace error "+unaryExpression.b3);
 	  }
	  if (unaryExpression.expr !== null) expr=setNamespace(ns,unaryExpression.expr);
	  ns.setUnaryOp(48,expr,unaryExpression.uop);
	  return ns;
	}

    /**
     * Tuple */
	def NamespaceScope setNamespace(NamespaceScope parent,Tuple expr) {
		val TupleScope ns = new TupleScope(parent,null);
	    parent.addSubscope(ns);
	    var NamespaceScope t5 = null;
	    var NamespaceScope t3 = null;
	    if (expr.t3 !== null) {
	        t3=setNamespace(ns,expr.t3);
	        ns.addParam(t3);
	    }
	    for (Statement x:expr.t5) {
	        t5=setNamespace(ns,x);
	        ns.addParam(t5);
	    }
	    return ns;
	}

    /**
     * Block 
     	({Block} b?=BEGIN
		(s+=Statement NL)*
	END )
	|
	({Block} c2?=KW_OCURLY (s+=Statement NL)* KW_CCURLY )
	|
	({Block} c3?=KW_OCHEV m?=KW_MINUS? t4=WhereExpression KW_CCHEV )
     */
	def NamespaceScope setNamespace(NamespaceScope parent,Block expr) {
		if (expr.c3) {
		  val UnaryOpScope ns = new UnaryOpScope(parent,null);
	      parent.addSubscope(ns);
	      if (expr.t4 !== null){
	        var NamespaceScope t4=setNamespace(ns,expr.t4);
	        ns.setMinusExpr(t4,expr.m);
	      }
		  return ns;
		}
		val BlockScope ns = new BlockScope(parent,null);
	    parent.addSubscope(ns);
	    for (Statement x:expr.s) {
	        var NamespaceScope st=setNamespace(ns,x);
	        ns.addStatement(st);
	    }
	    return ns;
	}

    /**
     * VarOrFunction  */
	def NamespaceScope setNamespace(NamespaceScope parent,VarOrFunction varOrFunction) {
      var String nam = varOrFunction.name;
	  var NamespaceScope ns = null;
	  var boolean isVar=true;
	  if (varOrFunction.expr !== null) {
	    isVar=false;
        if (varOrFunction.expr instanceof UnaryExpression) {
	      var UnaryExpression u = varOrFunction.expr as UnaryExpression
	      if (u.uop == ":") isVar=true;
	    }
	  }
	  if (isVar) {
	  	ns = new VarCallScope(parent,nam);
	  } else {
	  	ns = new FunctionCallScope(parent,nam)
	  }
	  parent.addSubscope(ns);
	  if (isVar) {
	  	ns.addVariableCall(nam,false)
	  } else { //if (refType != RefType.Parameter) {
	  	ns.addFunctionCall(nam,varOrFunction.expr,currentFunction,currentFile);
	  }
	  if (varOrFunction.expr !== null) {
      	var NamespaceScope expr = setNamespace(ns,varOrFunction.expr);
      	ns.setVarOrFunctionExpr(nam,expr);
	  }
      return ns;
    }

    /**
     * compileSignature: version of VarOrFunction for lambda */
	def SignatureScope compileSignature(NamespaceScope parent,VarOrFunction varOrFunction) {
      var String nam = varOrFunction.name;
	  var SignatureScope ns = new SignatureScope(parent,nam);
	  parent.addSubscope(ns);
	  if (varOrFunction.expr !== null) {
      	var ArrayList<ParameterScope> params = compileSignatureParams(ns,varOrFunction.expr);
      	ns.setVarOrFunctionExpr(nam,params);
	  }
      return ns;
    }

    /** compileSignatureParams: reads params for lambda */
	def  ArrayList<ParameterScope> compileSignatureParams(NamespaceScope parent,Expr exp) {
	  if (exp instanceof Tuple) {
	  	val Tuple t = exp as Tuple;
	    return compileLambdaTuple(parent,t);
	  } else if (exp instanceof VarOrFunction) {
	  	val VarOrFunction t = exp as VarOrFunction;
	    return compileLambdaVariable(parent,t);
	  } else if (exp instanceof ListLiteral) {
	  	val ListLiteral t = exp as ListLiteral;
	    return compileLambdaList(parent,t);
	  } else {
	  	System.err.println("EditorGenerator.compileSignatureParams unexpected type: "+exp);
	  	return new ArrayList<ParameterScope>();
	  }
    }

    /** compileLambdaTuple : When reading parameters of lambda definition
     * reads Tuple and converts to VariableTree list */
	def ArrayList<ParameterScope> compileLambdaTuple(NamespaceScope parent,Tuple expr) {
		var ArrayList<ParameterScope> res = new ArrayList<ParameterScope>();
		val TupleScope ns = new TupleScope(parent,null);
	    parent.addSubscope(ns);
	    var NamespaceScope t5 = null;
	    var NamespaceScope t3 = null;
	    if (expr.t3 !== null) {
	        t3=setNamespace(ns,expr.t3);
	        if (t3 === null) {
		      System.err.println("EditorGenerator.compileLambdaTuple: t3 == null");
	        }
	        val VariableTree vt = new VariableTree(t3);
	        var ParameterScope par = new ParameterScope(parent,null)
	        par.addParameterInfo2(vt);
	        res.add(par);
	    }
	    for (Statement x:expr.t5) {
	        t5=setNamespace(ns,x);
	        if (t5 === null) {
		      System.err.println("EditorGenerator.compileLambdaTuple: t5 == null");
	        }
	        val VariableTree vt = new VariableTree(t5);
	        var ParameterScope par = new ParameterScope(parent,null)
	        par.addParameterInfo2(vt);
	        res.add(par);
	    }
	    return res;
	}

/** compileLambdaVariable : When reading single parameter of lambda definition
 * reads variable and converts to VariableTree list */
  def ArrayList<ParameterScope> compileLambdaVariable(NamespaceScope parent,VarOrFunction varOrFunction) {
    var ArrayList<ParameterScope> res = new ArrayList<ParameterScope>();
    var String nam = varOrFunction.name;
    val VariableTree vt = new VariableTree(nam,null);
    var ParameterScope par = new ParameterScope(parent,null)
    par.addParameterInfo2(vt);
    res.add(par);
	if (varOrFunction.expr !== null) {
		System.err.println("EditorGenerator.compileLambdaVariable: Lambda parameter is function"+varOrFunction.expr);
	}
	return res;
  }

/** compileLambdaVariable : When reading single parameter of lambda definition
 * reads variable and converts to VariableTree list */
  def ArrayList<ParameterScope> compileLambdaList(NamespaceScope parent,ListLiteral listLiteral) {
    var ArrayList<ParameterScope> res = new ArrayList<ParameterScope>();
    val VariableTree vt = new VariableTree(listLiteral,new ArrayList<Integer>());
    var ParameterScope par = new ParameterScope(parent,null)
    par.addParameterInfo2(vt);
    res.add(par);
	return res;
  }

  /** display parameters : used for debugging */
  def StringBuilder displayParams(ArrayList<VariableTree> params){
  	val StringBuilder res = new StringBuilder("(");
    for (VariableTree p:params) {
      if (p !== null) {
      	res.append(p.display());
      	res.append(",");
      }
    }
    res.append(")");
    return res;
  }

/*        var ArrayList<VariableTree> params = new ArrayList<VariableTree>();//typeFromTuple(t);
        for (VariableTree p:params) {
          var String nm = "unknown name";
          //if (p != null) nm = p.display();
          var ParameterScope ps = new ParameterScope(ns,nm);
//          ns.addParameter(ps);
          ns.addSubscope(ps);
//          val NamespaceScope parSc = setNamespace(ns,p)
//          ps.addParameterInfo(parSc);
        }
 
//      	var NamespaceScope expr = setNamespace(ns,varOrFunction.expr);
//      	ns.setVarOrFunctionExpr(null,expr);
	  }*/


    /** This is a utility function which expects to have a tuple with all parameter
     * names as IDs which it returns as Strings.
     * Used by LambdaExpression below*/
 /*   def ArrayList<VariableTree> typeFromTuple(Tuple t) {
    	var ArrayList<VariableTree> res = new ArrayList<VariableTree>();
    	if (t === null) return res;
    	if (t.t3 !== null) {
    	  res.add(new VariableTree(t.t3));
    	}
    	for (Expr p: t.t5) {
    		res.add(new VariableTree(p));
    	}



    	return res;
    }*/


    /**
     * Literal  */
	def NamespaceScope setNamespace(NamespaceScope parent,Literal literal) {
        if (literal instanceof ListLiteral) return setNamespace(parent,literal as ListLiteral);
        if (literal instanceof LispLiteral) return setNamespace(parent,literal as LispLiteral);
		val LiteralScope ns = new LiteralScope(parent,null);
	    parent.addSubscope(ns);
	    val boolean d = literal.d;
	    val String value = literal.value;
	    val String bool = literal.bool;
	    val String nil = literal.nil;
	    val String str = literal.str;
        ns.setLiteral(d,value,bool,nil,str);
        return ns;
	}

    /**
     * LispLiteral  */
	def NamespaceScope setNamespace(NamespaceScope parent,LispLiteral lispLiteral) {
		val LispLiteralScope ns = new LispLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    if (lispLiteral.sll !== null) {
	      var NamespaceScope sll=setNamespace(ns,lispLiteral.sll);
	      ns.setLL(0,sll);
	    }
	    return ns;
	}

    /**
     * SubLispLiteral */
	def NamespaceScope setNamespace(NamespaceScope parent,SubLispLiteral subLispLiteral) {
// The following seems to corrupt the scope tree.
//
//		var String nam = "error";
//		if (subLispLiteral !== null) {
//			nam = cleanID(subLispLiteral.name)
//		}
		val LispSubLiteralScope ns = new LispSubLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    for (AnnotatedSubLispLiteral x:subLispLiteral.asl) {
	      var NamespaceScope asll=setNamespace(ns,x);
	      ns.addAsl(asll);
	    }
	    ns.setLSL(subLispLiteral.name,subLispLiteral.key,subLispLiteral.m,subLispLiteral.num,subLispLiteral.st)
	    return ns;
	}

    /**
     * AnnotatedSubLispLiteral */
	def NamespaceScope setNamespace(NamespaceScope parent,AnnotatedSubLispLiteral annotatedSubLispLiteral) {
		val LispAnnotatedSubLiteralScope ns = new LispAnnotatedSubLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    if (annotatedSubLispLiteral.sl !== null) {
	      var NamespaceScope sll=setNamespace(ns,annotatedSubLispLiteral.sl);
	      ns.setASLL(annotatedSubLispLiteral.p,sll,annotatedSubLispLiteral.d);
	    }
	    return ns;
	}

    /**
     * ListLiteral  */
	def NamespaceScope setNamespace(NamespaceScope parent,ListLiteral listLiteral) {
		val ListLiteralScope ns = new ListLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    for (ListElement x:listLiteral.le) {
	      var NamespaceScope listElement = setNamespace(ns,x);
	      ns.addSLL(listElement);
	    }
	    for (ListComprehension x:listLiteral.sl) {
	      var NamespaceScope listComprehension = setNamespace(ns,x);
	      ns.setSLL(listComprehension);
	    }
	    return ns;
	}

    /**
     * ListElement */
	def NamespaceScope setNamespace(NamespaceScope parent,ListElement listElement) {
		val ListElementLiteralScope ns = new ListElementLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    var NamespaceScope listComprehension = null;
	    if (listElement.l2 !== null) {
	      listComprehension = setNamespace(ns,listElement.l2);
	    }
	    ns.setLEL(listElement.c,listElement.e,listComprehension,listElement.c2,listElement.d);
	    return ns;
	}

    /**
     * ListComprehension */
	def NamespaceScope setNamespace(NamespaceScope parent,ListComprehension listComprehension) {
		val ListComprehensionLiteralScope ns = new ListComprehensionLiteralScope(parent,null);
	    parent.addSubscope(ns);
	    if (listComprehension.sl2 !== null) {
	      var NamespaceScope listSl2 = setNamespace(ns,listComprehension.sl2);
	      ns.setLC(listSl2,listComprehension.sl1,listComprehension.r);
	    }
	    return ns;
	}

/* Code Generator Template Notes
 * -----------------------------
 * Template commands:
 * 
 * FOR
 * ENDFOR
 * IF
 * ELSE
 * ENDIF
 * ELSEIF
 * 
 * To display filename use:
 *      «IF function.eContainer !== null»
 *           function «function.eResource.className»;
 *      «ENDIF»
 *
 * To use Booleans:
 *
 *    «IF block.b»true«ELSE»false«ENDIF»
 */
}