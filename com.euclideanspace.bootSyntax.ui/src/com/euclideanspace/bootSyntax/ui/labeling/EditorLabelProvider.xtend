/*
 * generated by Xtext 2.12.0
 */
package com.euclideanspace.bootSyntax.ui.labeling

import com.google.inject.Inject
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import com.euclideanspace.bootSyntax.editor.Model
import com.euclideanspace.bootSyntax.editor.Declaration
import com.euclideanspace.bootSyntax.editor.Package
import com.euclideanspace.bootSyntax.editor.Comment
import com.euclideanspace.bootSyntax.editor.Documentation
import com.euclideanspace.bootSyntax.editor.Defparameter
import com.euclideanspace.bootSyntax.editor.Defconst
import com.euclideanspace.bootSyntax.editor.Defvar
import com.euclideanspace.bootSyntax.editor.FunctionDef
import com.euclideanspace.bootSyntax.editor.GlobalVariable
import com.euclideanspace.bootSyntax.editor.Statement
//import com.euclideanspace.bootSyntax.editor.MultiAssign
//import com.euclideanspace.bootSyntax.editor.MultiDefine
//import com.euclideanspace.bootSyntax.editor.MultiExit
import com.euclideanspace.bootSyntax.editor.Loop
import com.euclideanspace.bootSyntax.editor.While
import com.euclideanspace.bootSyntax.editor.Do
import com.euclideanspace.bootSyntax.editor.Until
import com.euclideanspace.bootSyntax.editor.For
import com.euclideanspace.bootSyntax.editor.Where
import com.euclideanspace.bootSyntax.editor.Expr
import com.euclideanspace.bootSyntax.editor.Expression
import com.euclideanspace.bootSyntax.editor.OrExpression
import com.euclideanspace.bootSyntax.editor.AndExpression
import com.euclideanspace.bootSyntax.editor.EqualityExpression
import com.euclideanspace.bootSyntax.editor.RelationalExpression
import com.euclideanspace.bootSyntax.editor.IsExpression
import com.euclideanspace.bootSyntax.editor.InExpression
import com.euclideanspace.bootSyntax.editor.SegmentExpression
import com.euclideanspace.bootSyntax.editor.AdditiveExpression
import com.euclideanspace.bootSyntax.editor.ExquoExpression
import com.euclideanspace.bootSyntax.editor.DivisionExpression
import com.euclideanspace.bootSyntax.editor.QuoExpression
import com.euclideanspace.bootSyntax.editor.ModExpression
import com.euclideanspace.bootSyntax.editor.RemExpression
import com.euclideanspace.bootSyntax.editor.MultiplicativeExpression
import com.euclideanspace.bootSyntax.editor.ExponentExpression
import com.euclideanspace.bootSyntax.editor.MapExpression
import com.euclideanspace.bootSyntax.editor.AssignExpression
import com.euclideanspace.bootSyntax.editor.ExitExpression
import com.euclideanspace.bootSyntax.editor.EltExpression
import com.euclideanspace.bootSyntax.editor.UnaryExpression
import com.euclideanspace.bootSyntax.editor.VarOrFunction
import com.euclideanspace.bootSyntax.editor.Tuple
import com.euclideanspace.bootSyntax.editor.Literal
import com.euclideanspace.bootSyntax.editor.LispLiteral
import com.euclideanspace.bootSyntax.editor.SubLispLiteral
import com.euclideanspace.bootSyntax.editor.ListLiteral
import com.euclideanspace.bootSyntax.editor.AnnotatedSubLispLiteral
import com.euclideanspace.bootSyntax.editor.ListElement
import com.euclideanspace.bootSyntax.editor.ListComprehension
import com.euclideanspace.bootSyntax.editor.LoopCondition
import com.euclideanspace.bootSyntax.editor.WhereExpression
import com.euclideanspace.bootSyntax.editor.IfExpression
import com.euclideanspace.bootSyntax.editor.LambdaExpression
import com.euclideanspace.bootSyntax.editor.Block

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
class EditorLabelProvider extends DefaultEObjectLabelProvider {

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	def String text(Model ele) {
	  return "Model";
	}
	
	def String text(Declaration ele) {
	  return "Decl";
	}
	
	def String text(Comment ele) {
	  if (ele.getC()!==null)  return "C="+ele.getC()
	  return "C";
	}
	
	def String text(Package ele) {
	  if (ele.getP()!==null)  return "Package "+ele.getP()
	  return "Package";
	}

	def String text(Documentation ele) {
	  if (ele.getE()!==null)  return "Documentation "+ele.getE()
	  return "Documentation";
	}
	
	
	def String text(Defparameter ele) {
	  if (ele.getName()!==null)  return "Defparameter="+ele.getName()
	  return "Defparameter";
	}
	
	def String text(Defconst ele) {
	  if (ele.getName()!==null)  return "Defconst="+ele.getName()
	  return "Defconst";
	}
	
	def String text(Defvar ele) {
	  if (ele.getName()!==null)  return "Defvar="+ele.getName()
	  return "Defvar";
	}
	
	def String text(FunctionDef ele) {
	  if (ele.getName()!==null)  return "FunctionDef="+ele.getName()
	  return "FunctionDef";
	}
	
	def String text(GlobalVariable ele) {
	  if (ele.getName()!==null)  return "GlobalVariable="+ele.getName()
	  return "GlobalVariable";
	}
	
/* 	def String text(Block ele) {
	  return "Block";
	}
	
	def String text(InnerBlock ele) {
	  return "InnerBlock";
	}
*/	
	def String text(Statement ele) {
	  return "Statement";
	}
	
/* 	def String text(MultiAssign ele) {
	  if (ele.getE()!==null)  return "MultiAssign ..."
	  return "MultiAssign";
	}
	
	def String text(MultiDefine ele) {
	  if (ele.getE()!==null)  return "MultiDefine ..."
	  return "MultiDefine";
	}
	
	def String text(MultiExit ele) {
	  if (ele.getE()!==null)  return "MultiExit ..."
	  return "MultiExit";
	}*/

/* Loop:
	c+=LoopCondition* (KW_BAR e=Expression)? 'repeat' b=Block */
	def String text(Loop ele) {
	  if (ele.getE()!==null)  return "Loop ...|..."
	  return "Loop ...";
	}

/* LoopCondition:
	(w=While | f=For | u=Until) */
	def String text(LoopCondition ele) {
	  if (ele.getF()!==null)  return "Loop for"
	  if (ele.getW()!==null)  return "Loop while"
	  if (ele.getU()!==null)  return "Loop until"
	  return "LoopCondition empty";
	}

/* While:
	'while' b=InnerBlock */
	def String text(While ele) {
	  if (ele.getE()!==null)  return "While ..."
	  return "While";
	}

/* Do:
	'do' b=Block
 */
	def String text(Do ele) {
	  if (ele.getE()!==null)  return "Do ..."
	  return "Do";
	}

/*Until:
	'until' b=Block
*/
	def String text(Until ele) {
	  if (ele.getE()!==null)  return "Until ..."
	  return "Until";
	}
	
	def String text(For ele) {
	  if (ele.getE()!==null)  return "For ..."
	  return "For";
	}
	
	def String text(Where ele) {
	  if (ele.getB()!==null)  return "Where ..."
	  return "Where";
	}

	def String text(WhereExpression ele) {
	  if (ele.getW()!==null)  return "WhereExpression with where"
	  return "WhereExpression";
	}
	
	def String text(IfExpression ele) {
	  var String ret = ""
	  if (ele.i1!==null) ret = ret + " if ..."
	  if (ele.i2!==null) ret = ret + " then ..."
	  if (ele.i3!==null) ret = ret + " else ..."
	  return "IfExpression" +ret;
	}

/*PrimaryExpression returns Expr:
  (
	l=Literal
	| p?=KW_OPAREN m?=KW_MINUS? (t4=WhereExpression (KW_COMMA t5+=WhereExpression)*)? (
	b?=BEGIN
		(s+=Statement NL)*
	END NL
	)? KW_CPAREN
  )
  d=KW_2DOT? // for segment with no end part
  * 
  * WhereExpression returns Expr:
	(Expression ({WhereExpression.left=current} w=Where)?)
	|
	c?=KW_OCURLY (st+=Statement NL)* KW_CCURLY
	|
	(
	    'if' b1=InnerBlock
	    (
          =>('then' b2i=InnerBlock 'else' b3=Block) |
          ('then' b2=Block)
        )	
	)
 */
	def String text(Expr ele) {
	  var String res = "";
	  if (ele.getB1()!==null) res = res+ "if .. then .."
	  if (ele.getB3()!==null) res = res+ "else .."
	  return "Expr "+res;
	}

/*{Tuple} p?=KW_OPAREN m2?=KW_MINUS? (t3=WhereExpression NL? (KW_COMMA t5+=WhereExpression)*)? */
	def String text(Tuple ele) {
	  var String res = "(";
	  if (ele.isM2())  res = res+ "-"
	  if (ele.getT3()!==null)  res = res+ "exp"
//	  if (ele.getT5()!==null) res = res+ ",exp..."
	  return "Tuple "+res+")";
	}
	
	def String text(Block ele) {
	  var String res = "(";
	  if (ele.isC2())  res = res+ "{...}"
	  if (ele.isM())  res = res+ "-"
	  if (ele.isB())  res = res+ " block"
	  if (ele.isD()) res = res+ ".."
	  return "Block "+res+")";
	}
	
	def String text(Expression ele) {
	  if (ele.getOp()!==null)  return "Expression "+ele.getOp()
	  return "Expression";
	}


	def String text(OrExpression ele) {
	  if (ele.getOp()!==null)  return "OrExpression "+ele.getOp()
	  return "OrExpression";
	}
	
	
	def String text(AndExpression ele) {
	  if (ele.getOp()!==null)  return "AndExpression "+ele.getOp()
	  return "AndExpression";
	}
	
	def String text(EqualityExpression ele) {
	  if (ele.getOp()!==null)  return "EqualityExpression "+ele.getOp()
	  return "EqualityExpression";
	}
	
	
	def String text(RelationalExpression ele) {
	  if (ele.getOp()!==null)  return "RelationalExpression "+ele.getOp()
	  return "RelationalExpression";
	}
	
	
	def String text(IsExpression ele) {
	  if (ele.getOp()!==null)  return "IsExpression "+ele.getOp()
	  return "IsExpression";
	}
	
	def String text(InExpression ele) {
	  if (ele.getOp()!==null)  return "InExpression "+ele.getOp()
	  return "InExpression";
	}
	
	
	def String text(SegmentExpression ele) {
	  if (ele.getOp()!==null)  return "SegmentExpression "+ele.getOp()
	  return "SegmentExpression";
	}
	
	
	def String text(AdditiveExpression ele) {
	  if (ele.getOp()!==null)  return "AdditiveExpression "+ele.getOp()
	  return "AdditiveExpression";
	}
	
	
	def String text(ExquoExpression ele) {
	  if (ele.getOp()!==null)  return "ExquoExpression "+ele.getOp()
	  return "ExquoExpression";
	}
	
	
	def String text(DivisionExpression ele) {
	  if (ele.getOp()!==null)  return "DivisionExpression "+ele.getOp()
	  return "DivisionExpression";
	}
	
	
	def String text(QuoExpression ele) {
	  if (ele.getOp()!==null)  return "QuoExpression "+ele.getOp()
	  return "QuoExpression";
	}
	
	
	def String text(ModExpression ele) {
	  if (ele.getOp()!==null)  return "ModExpression "+ele.getOp()
	  return "ModExpression";
	}

	def String text(RemExpression ele) {
	  if (ele.getOp()!==null)  return "RemExpression "+ele.getOp()
	  return "RemExpression";
	}
	
	
	def String text(MultiplicativeExpression ele) {
	  if (ele.getOp()!==null)  return "MultiplicativeExpression "+ele.getOp()
	  return "MultiplicativeExpression";
	}

	def String text(ExponentExpression ele) {
	  if (ele.getOp()!==null)  return "ExponentExpression "+ele.getOp()
	  return "ExponentExpression";
	}

	def String text(MapExpression ele) {
	  if (ele.getOp()!==null)  return "MapExpression "+ele.getOp()
	  return "MapExpression";
	}
	
	def String text(LambdaExpression ele) {
	  if (ele.getOp()!==null)  return "LambdaExpression "+ele.getOp()
	  return "LambdaExpression";
	}

	def String text(AssignExpression ele) {
	  if (ele.getOp()!==null)  return "AssignExpression "+ele.getOp()
	  return "AssignExpression";
	}
	
	def String text(ExitExpression ele) {
	  if (ele.getOp()!==null)  return "ExitExpression "+ele.getOp()
	  return "ExitExpression";
	}
	
	
	def String text(EltExpression ele) {
	  if (ele.getOp()!==null)  return "EltExpression "+ele.getOp()
	  return "EltExpression";
	}

/*UnaryExpression returns Expr:
PrimaryExpression |
({UnaryExpression} name=TK_ID => p2?=KW_PRIME? expr=UnaryExpression?) |
({UnaryExpression} uop=KW_DOLLAR expr=UnaryExpression) |
({UnaryExpression} uop='not' expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON expr=UnaryExpression) |
({UnaryExpression} uop='or/' expr=UnaryExpression) |
({UnaryExpression} uop='and/' expr=UnaryExpression) |
({UnaryExpression} uop='+/' expr=UnaryExpression) |
({UnaryExpression} uop='*./' expr=UnaryExpression) | // needs . otherwise causes errors in xtext files
({UnaryExpression} uop='return' expr=UnaryExpression) |
({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON loc?='local') //|
 */
	def String text(UnaryExpression ele) {
	  var String res = "";
	  if (ele.getUop()!==null) res=res+ele.getUop()
	  if (ele.loc) res=res+"local"
	  return "UnaryExpression " +res;
	}

/*UnaryExpression returns Expr:
PrimaryExpression  |
({VarOrFunction} name=TK_ID =>p2?=KW_PRIME? expr=UnaryExpression?) |
({UnaryExpression} uop='not' expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON expr=UnaryExpression) |
({UnaryExpression} uop='or/' expr=UnaryExpression) |
({UnaryExpression} uop='and/' expr=UnaryExpression) |
({UnaryExpression} uop='+/' expr=UnaryExpression) |
({UnaryExpression} uop='*./' expr=UnaryExpression) | // needs . otherwise causes errors in xtext files
({UnaryExpression} uop='return' expr=UnaryExpression) |
({UnaryExpression} uop=KW_SHARP expr=UnaryExpression) |
({UnaryExpression} uop=KW_COLON loc?='local') */
	def String text(VarOrFunction ele) {
	  var String res = "";
	  if (ele.getName()!==null) res=res+ele.getName()
//	  if (ele.p2) res=res+"'"
	  if (ele.expr!==null) res=res+" expr"
	  return "VarOrFunction " +res;
	}

/*Literal:
  // numeric literal
  value=Numeric
  // boolean literals
| bool='true'
| bool='false'
  // null
| nil='NIL'
| nil='nil'
  // other
| lst=ListLiteral
| lsp=LispLiteral
| str=TK_STRING */
	def String text(Literal ele) {
	  if (ele.getValue()!==null) {
	  	var res= "Numeric Literal "+ele.getValue()
	    if (ele.isD()) res = res+ ".."
	  	return res
	  }
	  if (ele.getBool()!==null)  return "Boolean Literal "+ele.getBool()
	  if (ele.getNil()!==null)  return "Nil Literal "+ele.getNil()
	  if (ele.getStr()!==null)  return "String Literal "+ele.getStr()
	  return "Literal";
	}

/*LispLiteral:
  p+=KW_PRIME+ sll=SubLispLiteral
 */	
	def String text(LispLiteral ele) {
	  return "LispLiteral";
	}

/*SubLispLiteral:
	name=TK_ID 
	|
    key=('not' | 'and' | 'or' | 'for' | 'while' | 'where' | 'local' | 'package' | 'exquo' |
    'true' | 'false' | 'is' | 'isnt' | 'repeat' |'until' | 'DEFPARAMETER' | 'DEFCONST'|
    'DEFCONSTANT' | 'DEFVAR' |
	'NIL' | 'nil')
	|
	m?=KW_MINUS? num=Numeric
	|
	NL? st=TK_STRING
	|
	( NL? oparen?=KW_OPAREN asl+=AnnotatedSubLispLiteral* KW_CPAREN)
 */	
	def String text(SubLispLiteral ele) {
	  var String res = "";
	  if (ele.getName()!==null)  res = res+ele.getName();
	  if (ele.key !==null)  res = res+ele.key;
	  if (ele.m)  res = res+"-"+ele.num;
	  if (ele.st !==null)  res = res+ele.st;
	  if (ele.oparen)  res = res+"()";
	  return "SubLispLiteral "+res;
	}

/* AnnotatedSubLispLiteral:
 *   p?=KW_PRIME? sl=SubLispLiteral d?=KW_DOT?
 * */
	def String text(AnnotatedSubLispLiteral ele) {
	  var String res = "";
	  if (ele.p) res = "prime";
	  res = res + "(...)"
	  if (ele.d) res = res + "dot";
	  return "AnnotatedSubLispLiteral "+res;
	}

/* ListLiteral:
 * // may be empty list so ob ensures literal is created
 * ob?= KW_OBRACK
 * le+=ListElement?
 * (KW_COMMA NL? le+=ListElement)*
 * sl+=ListComprehension*
 * KW_CBRACK
 */
	def String text(ListLiteral ele) {
	  return "ListLiteral";
	}

/* ListElement:
 * (
 * 	(c?=KW_COLON? e?=KW_EQ)? l2=IfExpression |
 * 	c2?=KW_COLON? d?=KW_DOT
 * )
 */
	def String text(ListElement ele) {
	  var String res = "";
	  if (ele.c) res = ":";
	  if (ele.e) res = res+"=";
	  if (ele.l2 !== null) res = res+"(...)";
	  if (ele.c2) res = res+":";
	  if (ele.d) res = res+".";
	  return "ListElement "+res;
	}

/* ListComprehension:
  (sl1=('for'|'while'|'where'|KW_BAR) sl2=Expression
  	|
  	r?='repeat'
  )
 */
	def String text(ListComprehension ele) {
	  var String res = "";
	  if (ele.r) res = res+" repeat" else res = res+ele.sl1;
	  return "ListComprehension "+ele.sl1;
	}
}

	
